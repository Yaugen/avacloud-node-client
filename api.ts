/**
 * AVACloud API 1.31.1-beta0004
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.31.1-beta0004
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://avacloud-api-dev.dangl-it.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        if (type === 'ProjectDto') {
            return data;
        }
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* This enumeration represents the status of an addendum, 'Nachtrag' in German
*/
export class AddendumStatusDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AddendumStatusDto.attributeTypeMap;
    }
}

/**
* Indicates the origin of an element.
*/
export class AdditionTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdditionTypeDto.attributeTypeMap;
    }
}

/**
* Data transfer class to convey api errors
*/
export class ApiError {
    /**
    * This dictionary contains a set of all errors and their messages
    */
    'errors'?: { [key: string]: Array<string>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "{ [key: string]: Array<string>; }"
        }    ];

    static getAttributeTypeMap() {
        return ApiError.attributeTypeMap;
    }
}

/**
* This class represents a single article, usually used within ProductData
*/
export class ArticleDataDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The name (or brand name) for this article, usually given by the supplier or vendor.
    */
    'name'?: string;
    /**
    * An article number that describes it, useful when integrating other systems.
    */
    'articleNumber'?: string;
    /**
    * Quantity for this article. If this is used within a Position, the quantity here should be the quantity required for the full quantity of the position, not for a single unit.
    */
    'quantity': number;
    /**
    * The unit tag for this single ArticleData.
    */
    'unitTag'?: string;
    /**
    * This is an optional text element that can be used to further describe the ArticleData.
    */
    'description'?: string;
    /**
    * Short description for this ITextElement element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "articleNumber",
            "baseName": "articleNumber",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitTag",
            "baseName": "unitTag",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "shortText",
            "baseName": "shortText",
            "type": "string"
        },
        {
            "name": "longText",
            "baseName": "longText",
            "type": "string"
        },
        {
            "name": "htmlLongText",
            "baseName": "htmlLongText",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ArticleDataDto.attributeTypeMap;
    }
}

/**
* This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard
*/
export class AwardTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AwardTypeDto.attributeTypeMap;
    }
}

/**
* This is a class that represents the information about a bank connection. It is usually used within a PartyInformation.
*/
export class BankingInformationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The name of the bank.
    */
    'name'?: string;
    /**
    * The international identifier for the bank account.
    */
    'iban'?: string;
    /**
    * The account number. Typically no longer used since the introduction of IBAN within the SEPA area.
    */
    'accountNumber'?: string;
    /**
    * The international bank identifier.
    */
    'bic'?: string;
    /**
    * The routing number for the bank. Typically no longer used since the introduction of IBAN within the SEPA area.
    */
    'routingNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "bic",
            "baseName": "bic",
            "type": "string"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankingInformationDto.attributeTypeMap;
    }
}

/**
* This class holds means to calculate mathematical expressions from given strings.
*/
export class CalculationDto {
    /**
    * Descriptive text for this calculation.
    */
    'description'?: string;
    /**
    * This Calculation's mathematical expression. Please note that thousands separators are not supported. Both comma and point will be treated as decimal separators.
    */
    'formula'?: string;
    /**
    * The calculated result from the formula, 0 if invalid.
    */
    'result': number;
    /**
    * Whether the Formula is a valid expression.
    */
    'valid': boolean;
    /**
    * Will be -1 if the Formula is correct, else it will show the position in the formula where an error was encountered. This is a zero based index.
    */
    'errorPositionInLine': number;
    /**
    * These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * Referenced catalogues for this Calculation.
    */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "formula",
            "baseName": "formula",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "number"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        },
        {
            "name": "errorPositionInLine",
            "baseName": "errorPositionInLine",
            "type": "number"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        },
        {
            "name": "catalogueReferences",
            "baseName": "catalogueReferences",
            "type": "Array<CatalogueReferenceDto>"
        }    ];

    static getAttributeTypeMap() {
        return CalculationDto.attributeTypeMap;
    }
}

/**
* This class describes an external catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
*/
export class CatalogueDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This is used to store the GAEB XML Id within this Catalogue. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    /**
    * The name that is given for this catalogue.
    */
    'name'?: string;
    /**
    * Additional information about this catalogue.
    */
    'description'?: string;
    /**
    * If given, this gives a classification for the contents of the catalogue
    */
    'catalogueType': CatalogueTypeDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "gaebXmlId",
            "baseName": "gaebXmlId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "catalogueType",
            "baseName": "catalogueType",
            "type": "CatalogueTypeDto"
        }    ];

    static getAttributeTypeMap() {
        return CatalogueDto.attributeTypeMap;
    }
}

/**
* This class is used to link data between catalogues and objects.
*/
export class CatalogueReferenceDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This points to the item in the catalogue itself. This means that, for example when this quantity assignment references a \"DIN 276\" catalogue, this property indicates the number / identifier / key in DIN 276 that is referenced.
    */
    'catalogueReferenceKey'?: string;
    /**
    * The Id of the CatalogueReference that is targeted by this item. Set this property to set the referenced catalogue.
    */
    'catalogueReferenceId': string;
    /**
    * These are CatalogueReference that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * This returns the referenced catalogue. Will return null if there is no reference or the catalogue is not present in the ProjectCatalogues.
    */
    'catalogue'?: CatalogueDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "catalogueReferenceKey",
            "baseName": "catalogueReferenceKey",
            "type": "string"
        },
        {
            "name": "catalogueReferenceId",
            "baseName": "catalogueReferenceId",
            "type": "string"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        },
        {
            "name": "catalogue",
            "baseName": "catalogue",
            "type": "CatalogueDto"
        }    ];

    static getAttributeTypeMap() {
        return CatalogueReferenceDto.attributeTypeMap;
    }
}

/**
* This enumeration describes the type of a catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
*/
export class CatalogueTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogueTypeDto.attributeTypeMap;
    }
}

/**
* Indicates if this service specification item is commissioned (and therefore should be executed), postponed for later or undefined.
*/
export class ComissionStatusDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ComissionStatusDto.attributeTypeMap;
    }
}

/**
* This class holds specialized information that is relevant to trade or commerce based data exchange scenarios, e.g. between customers, vendors, suppliers and distributors. It is used when exporting to GAEB XML 9x exchange phases.
*/
export class CommercePropertiesDto {
    /**
    * This maps to ArtNo in GAEB XML and represents an article number given by the supplier.
    */
    'articleNumber'?: string;
    /**
    * This maps to EAN in GAEB XML and represents an GTIN (formerly EAN) article number.
    */
    'eanGtinArticleNumber'?: string;
    /**
    * This maps to ArtNoID in GAEB XML and represents an ILN article number.
    */
    'ilnArticleNumber'?: string;
    /**
    * This maps to CatalogNo in GAEB XML and represents an identifier of a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences.
    */
    'catalogueNumber'?: string;
    /**
    * This maps to CatalogArtNo in GAEB XML and represents a key that maps to an entry in a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences.
    */
    'catalogueArticleNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "articleNumber",
            "baseName": "articleNumber",
            "type": "string"
        },
        {
            "name": "eanGtinArticleNumber",
            "baseName": "eanGtinArticleNumber",
            "type": "string"
        },
        {
            "name": "ilnArticleNumber",
            "baseName": "ilnArticleNumber",
            "type": "string"
        },
        {
            "name": "catalogueNumber",
            "baseName": "catalogueNumber",
            "type": "string"
        },
        {
            "name": "catalogueArticleNumber",
            "baseName": "catalogueArticleNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommercePropertiesDto.attributeTypeMap;
    }
}

/**
* This class represents the linking to a complementary position with a specific quantity set. For example, Position 'A' could be complementing Position 'B' with a total quantity of 20 units
*/
export class ComplementedByQuantityDto {
    /**
    * The quantity that is complemented. E.g., if the base position has a quantity of 100 m² of a brick wall, a complementing position might be for 'walls that exceed 3 m height' and for a total quantity of 10 m².
    */
    'quantity': number;
    /**
    * This is the reference to the Id of the Position that is complementing. This means it does NOT reference the base position but the one that contains the actual addition.
    */
    'complementingPositionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "complementingPositionId",
            "baseName": "complementingPositionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ComplementedByQuantityDto.attributeTypeMap;
    }
}

/**
* The GAEB exchange phase to transform to
*/
export class DestinationGaebExchangePhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DestinationGaebExchangePhase.attributeTypeMap;
    }
}

/**
* Represents valid GAEB target types
*/
export class DestinationGaebType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DestinationGaebType.attributeTypeMap;
    }
}

/**
* Represents valid Oenorm target types
*/
export class DestinationOenormType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DestinationOenormType.attributeTypeMap;
    }
}

/**
* Represents valid REB target types
*/
export class DestinationRebType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DestinationRebType.attributeTypeMap;
    }
}

/**
* This enumeration represents the unit of a duration
*/
export class DurationUnitDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DurationUnitDto.attributeTypeMap;
    }
}

/**
* Indicates a ServiceSpecification's exchange phase, based on the GAEB exchange phases.
*/
export class ExchangePhaseDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ExchangePhaseDto.attributeTypeMap;
    }
}

/**
* Base interface definition for elements within an ElementContainerBase.
*/
export class IElementDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This is used to store the GAEB XML Id within this IElement. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    /**
    * This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German.
    */
    'addendumNumber'?: string;
    'projectCatalogues'?: Array<CatalogueDto>;
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    'elementTypeDiscriminator': string;

    static discriminator: string | undefined = "elementTypeDiscriminator";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "gaebXmlId",
            "baseName": "gaebXmlId",
            "type": "string"
        },
        {
            "name": "addendumNumber",
            "baseName": "addendumNumber",
            "type": "string"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        },
        {
            "name": "catalogueReferences",
            "baseName": "catalogueReferences",
            "type": "Array<CatalogueReferenceDto>"
        },
        {
            "name": "elementTypeDiscriminator",
            "baseName": "elementTypeDiscriminator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IElementDto.attributeTypeMap;
    }
}

export class ExecutionDescriptionDto extends IElementDto {
    /**
    * Blocks within an ExecutionDescription contain the actual information.
    */
    'blocks'?: Array<NoteTextDto>;
    /**
    * Labels this ExecutionDescription.
    */
    'label'?: string;
    /**
    * Uniquely identifies this ExecutionDescription.
    */
    'identifier'?: string;
    'elementType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blocks",
            "baseName": "blocks",
            "type": "Array<NoteTextDto>"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "elementType",
            "baseName": "elementType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ExecutionDescriptionDto.attributeTypeMap);
    }
}

/**
* This enum represents the source type for a file based validation operation
*/
export class FileValidationSourceType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return FileValidationSourceType.attributeTypeMap;
    }
}

export class ForgotPasswordPost {
    'identifier': string;
    'preferredLanguages'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "preferredLanguages",
            "baseName": "preferredLanguages",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ForgotPasswordPost.attributeTypeMap;
    }
}

/**
* Indicates the status of the AVACloud service
*/
export class GetStatus {
    /**
    * If any problems in the service health are known, this is set to false
    */
    'isHealthy': boolean;
    /**
    * The current version of the AVACloud service
    */
    'version'?: string;
    /**
    * The environment of the current instance
    */
    'environment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isHealthy",
            "baseName": "isHealthy",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "environment",
            "baseName": "environment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetStatus.attributeTypeMap;
    }
}

/**
* This is used in an ElementContainerBase to hold the price composition.
*/
export class GrossPriceComponentDto {
    /**
    * This components tax rate.
    */
    'taxRate': number;
    /**
    * This is the factor of applied deductions for this component
    */
    'deductionFactor': number;
    /**
    * The total net price for all components of a given tax rate.
    */
    'totalNet': number;
    /**
    * The resulting price component after applied deductions
    */
    'totalDeducted': number;
    /**
    * The total tax amount for all components of a given tax rate.
    */
    'totalTax': number;
    /**
    * The total gross price for all components of a given tax rate.
    */
    'totalGross': number;
    /**
    * The total gross price for all components of a given tax rate, after applied deductions.
    */
    'totalGrossDeducted': number;
    /**
    * The total tax amount for all components of a given tax rate, after applied deductions.
    */
    'totalTaxDeducted': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "number"
        },
        {
            "name": "deductionFactor",
            "baseName": "deductionFactor",
            "type": "number"
        },
        {
            "name": "totalNet",
            "baseName": "totalNet",
            "type": "number"
        },
        {
            "name": "totalDeducted",
            "baseName": "totalDeducted",
            "type": "number"
        },
        {
            "name": "totalTax",
            "baseName": "totalTax",
            "type": "number"
        },
        {
            "name": "totalGross",
            "baseName": "totalGross",
            "type": "number"
        },
        {
            "name": "totalGrossDeducted",
            "baseName": "totalGrossDeducted",
            "type": "number"
        },
        {
            "name": "totalTaxDeducted",
            "baseName": "totalTaxDeducted",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GrossPriceComponentDto.attributeTypeMap;
    }
}

/**
* 
*/
export class HttpStatusCode {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return HttpStatusCode.attributeTypeMap;
    }
}

/**
* This class represents as identifier of a certain service specification's element and is uniquely within the service specification.
*/
export class ItemNumberDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * Will return this ItemNumber as point delimited string. Will not distinguish between upper- and lowercase and return an all-lowercase representation. Will consider first numbers, then characters, e.g. 1a is considered preceding aa.
    */
    'stringRepresentation'?: string;
    /**
    * Indicates if the characters and the length of the Identifiers match the current ItemNumberSchema.
    */
    'isSchemaCompliant': boolean;
    /**
    * Used for representing and validating this ItemNumber.
    */
    'itemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * Collection of the single identifiers in this ItemNumber. P.e., \"02.03.004\" will have three elements \"02\", \"03\", and \"004\". Since ReadOnlyObservableCollection`1 does have the event set to protected, it can be accessed like this: (itemNumber.Identifiers as INotifyCollectionChanged).CollectionChanged
    */
    'identifiers'?: Array<string>;
    /**
    * This indicates if this item number is at the lot level. Find out more about lots in the documentation.
    */
    'isLot': boolean;
    /**
    * This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
    */
    'hierarchyLevel': number;
    /**
    * This property indicates if this ItemNumber is attached to an object of the Position type.
    */
    'isAttachedToPosition': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "stringRepresentation",
            "baseName": "stringRepresentation",
            "type": "string"
        },
        {
            "name": "isSchemaCompliant",
            "baseName": "isSchemaCompliant",
            "type": "boolean"
        },
        {
            "name": "itemNumberSchema",
            "baseName": "itemNumberSchema",
            "type": "ItemNumberSchemaDto"
        },
        {
            "name": "identifiers",
            "baseName": "identifiers",
            "type": "Array<string>"
        },
        {
            "name": "isLot",
            "baseName": "isLot",
            "type": "boolean"
        },
        {
            "name": "hierarchyLevel",
            "baseName": "hierarchyLevel",
            "type": "number"
        },
        {
            "name": "isAttachedToPosition",
            "baseName": "isAttachedToPosition",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemNumberDto.attributeTypeMap;
    }
}

/**
* The schema for ItemNumber's in a Project.
*/
export class ItemNumberSchemaDto {
    /**
    * The count of tiers in the ItemNumberSchema
    */
    'totalLength': number;
    /**
    * The collection of tiers for this ItemNumberSchema.
    */
    'tiers'?: Array<ItemNumberSchemaTierDto>;
    /**
    * The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
    */
    'separator'?: string;
    /**
    * This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
    */
    'filler'?: string;
    /**
    * This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store ÖNorm service specification structure types.
    */
    'identifier'?: string;
    /**
    * This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
    */
    'skipNonExistingLevelsInPositionItemNumbers': boolean;
    /**
    * This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
    */
    'skippedTiersFiller'?: string;
    /**
    * This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
    */
    'schemaIsCorrectlyDefined': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalLength",
            "baseName": "totalLength",
            "type": "number"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<ItemNumberSchemaTierDto>"
        },
        {
            "name": "separator",
            "baseName": "separator",
            "type": "string"
        },
        {
            "name": "filler",
            "baseName": "filler",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "skipNonExistingLevelsInPositionItemNumbers",
            "baseName": "skipNonExistingLevelsInPositionItemNumbers",
            "type": "boolean"
        },
        {
            "name": "skippedTiersFiller",
            "baseName": "skippedTiersFiller",
            "type": "string"
        },
        {
            "name": "schemaIsCorrectlyDefined",
            "baseName": "schemaIsCorrectlyDefined",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemNumberSchemaDto.attributeTypeMap;
    }
}

/**
* Represents information about a single Tier in an ItemNumber.
*/
export class ItemNumberSchemaTierDto {
    /**
    * The (maximum) length for this tier. Will not accept a length less than 1. Defaults to 1 if length less than one is specified.
    */
    'length': number;
    /**
    * This ItemNumberSchemaTier's type.
    */
    'type': ItemNumberTypeDto;
    /**
    * This specifies which ItemNumberSchemaTierType this tier represents. This can be, for example, a group tier / level, a position level or a lot level.
    */
    'tierType': ItemNumberSchemaTierTypeDto;
    /**
    * Indicates if this tier represents a lot. See the documentation for more information about lots.
    */
    'isLot': boolean;
    /**
    * This value is the increment, or step size, that should be used for new item numbers. It defaults to DEFAULT_INCREMENT, but can be changed to any other positive number greater than zero. Invalid values make this be set to one '1'
    */
    'increment': number;
    /**
    * This is an optional name for the given tier
    */
    'tierName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "length",
            "baseName": "length",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ItemNumberTypeDto"
        },
        {
            "name": "tierType",
            "baseName": "tierType",
            "type": "ItemNumberSchemaTierTypeDto"
        },
        {
            "name": "isLot",
            "baseName": "isLot",
            "type": "boolean"
        },
        {
            "name": "increment",
            "baseName": "increment",
            "type": "number"
        },
        {
            "name": "tierName",
            "baseName": "tierName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemNumberSchemaTierDto.attributeTypeMap;
    }
}

/**
* Specifies the type an ItemNumberSchemaTier represents. For example, a tier may indicate to be used for positions or for groups.
*/
export class ItemNumberSchemaTierTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ItemNumberSchemaTierTypeDto.attributeTypeMap;
    }
}

/**
* Determines the type of an ItemNumberSchema
*/
export class ItemNumberTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ItemNumberTypeDto.attributeTypeMap;
    }
}

/**
* Based on the PriceComponent, this class is responsible for labour time components.
*/
export class LabourPriceComponentDto {
    /**
    * The label associated with this price component. Will be taken from the parent Projects ProjectInformation.
    */
    'label'?: string;
    /**
    * The total, calculated price of this component. Will multiply the calculated amount of hours with the ServiceSpecifications hourly wage rate.
    */
    'price': number;
    /**
    * The cost per hour of manual labor.
    */
    'hourlyWage': number;
    /**
    * The single Calculation elements this price component is composed of.
    */
    'values'?: Array<CalculationDto>;
    /**
    * Indicates if the ServiceSpecification's standard HourlyWage is to be used or a custom value.
    */
    'useOwnHourlyWage': boolean;
    /**
    * The total, calculated time of this component. Will return the result rounded to three decimal places.
    */
    'totalTime': number;
    /**
    * These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "hourlyWage",
            "baseName": "hourlyWage",
            "type": "number"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CalculationDto>"
        },
        {
            "name": "useOwnHourlyWage",
            "baseName": "useOwnHourlyWage",
            "type": "boolean"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "number"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        }    ];

    static getAttributeTypeMap() {
        return LabourPriceComponentDto.attributeTypeMap;
    }
}

export class LoginPost {
    'identifier': string;
    'password': string;
    'staySignedIn': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "staySignedIn",
            "baseName": "staySignedIn",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LoginPost.attributeTypeMap;
    }
}

export class NoteTextDto extends IElementDto {
    /**
    * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special opening text at the beginning of the project. For example, in GAEB XML, this would map to the GAEB.Award.AddText. Typically, such texts describe project-wide contractual definitions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
    */
    'isOpeningText': boolean;
    /**
    * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special closing text at the end of the project. For Example, in GAEB XML, this would map to the GAEB.AddText. Typically, such texts are used to describe project wide finishing descriptions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
    */
    'isClosingText': boolean;
    /**
    * Short description for this DescriptionBase element.
    */
    'shortText'?: string;
    /**
    * Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.
    */
    'additionType': AdditionTypeDto;
    /**
    * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    /**
    * This is an optional internal identifier that may be used to add additional information to this NoteText. It is not supported in GAEB import or export.
    */
    'identifier'?: string;
    /**
    * This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
    */
    'standardizedDescription'?: StandardizedDescriptionDto;
    'elementType'?: string;
    /**
    * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.
    */
    'descriptionId'?: string;
    /**
    * This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for NoteTexts.
    */
    'oenormNoteTextProperties'?: OenormNoteTextPropertiesDto;
    'hasBidderCommentInHtmlLongText': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isOpeningText",
            "baseName": "isOpeningText",
            "type": "boolean"
        },
        {
            "name": "isClosingText",
            "baseName": "isClosingText",
            "type": "boolean"
        },
        {
            "name": "shortText",
            "baseName": "shortText",
            "type": "string"
        },
        {
            "name": "additionType",
            "baseName": "additionType",
            "type": "AdditionTypeDto"
        },
        {
            "name": "longText",
            "baseName": "longText",
            "type": "string"
        },
        {
            "name": "htmlLongText",
            "baseName": "htmlLongText",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "standardizedDescription",
            "baseName": "standardizedDescription",
            "type": "StandardizedDescriptionDto"
        },
        {
            "name": "elementType",
            "baseName": "elementType",
            "type": "string"
        },
        {
            "name": "descriptionId",
            "baseName": "descriptionId",
            "type": "string"
        },
        {
            "name": "oenormNoteTextProperties",
            "baseName": "oenormNoteTextProperties",
            "type": "OenormNoteTextPropertiesDto"
        },
        {
            "name": "hasBidderCommentInHtmlLongText",
            "baseName": "hasBidderCommentInHtmlLongText",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NoteTextDto.attributeTypeMap);
    }
}

/**
* Basic information about Object check validation details, commonly used when checking GAEB 2000 files
*/
export class ObjectValidationCheckDetails {
    /**
    * The path under which the element with error was found.
    */
    'elementPath'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "elementPath",
            "baseName": "elementPath",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObjectValidationCheckDetails.attributeTypeMap;
    }
}

/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for NoteTexts.
*/
export class OenormNoteTextPropertiesDto {
    /**
    * This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
    */
    'originCode': OenormOriginCodeDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originCode",
            "baseName": "originCode",
            "type": "OenormOriginCodeDto"
        }    ];

    static getAttributeTypeMap() {
        return OenormNoteTextPropertiesDto.attributeTypeMap;
    }
}

/**
* This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
*/
export class OenormOriginCodeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OenormOriginCodeDto.attributeTypeMap;
    }
}

/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.
*/
export class OenormPositionPropertiesDto {
    /**
    * This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
    */
    'originCode': OenormOriginCodeDto;
    /**
    * This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in ÖNorm.
    */
    'openingTextIsFreeText': boolean;
    /**
    * This indicates if the ÖNorm 'wesentliche position' mark is set
    */
    'isMainPosition': boolean;
    /**
    * This indicates if the ÖNorm position was a 'ungeteilteposition' (undivided position). This will only be taken into account when the position is also the sole element inside it's parent group
    */
    'isUndividedPosition': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originCode",
            "baseName": "originCode",
            "type": "OenormOriginCodeDto"
        },
        {
            "name": "openingTextIsFreeText",
            "baseName": "openingTextIsFreeText",
            "type": "boolean"
        },
        {
            "name": "isMainPosition",
            "baseName": "isMainPosition",
            "type": "boolean"
        },
        {
            "name": "isUndividedPosition",
            "baseName": "isUndividedPosition",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OenormPositionPropertiesDto.attributeTypeMap;
    }
}

/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used.
*/
export class OenormPropertiesDto {
    /**
    * This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
    */
    'originCode': OenormOriginCodeDto;
    /**
    * This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in ÖNorm.
    */
    'openingTextIsFreeText': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originCode",
            "baseName": "originCode",
            "type": "OenormOriginCodeDto"
        },
        {
            "name": "openingTextIsFreeText",
            "baseName": "openingTextIsFreeText",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OenormPropertiesDto.attributeTypeMap;
    }
}

/**
* Indicates where a service specification was originally created.
*/
export class OriginDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OriginDto.attributeTypeMap;
    }
}

/**
* Represents information about a party (a site or an organization).
*/
export class PartyInformationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This party's name.
    */
    'name'?: string;
    /**
    * This party's street.
    */
    'street'?: string;
    /**
    * This party's ZipCode.
    */
    'zipCode'?: string;
    /**
    * This party's City.
    */
    'city'?: string;
    /**
    * This party's Country.
    */
    'country'?: string;
    /**
    * This party's Identifier.
    */
    'identifier'?: string;
    /**
    * Remarks for this party.
    */
    'remarks'?: string;
    /**
    * An email address for this party.
    */
    'email'?: string;
    /**
    * A phone number for this party.
    */
    'phone'?: string;
    /**
    * The name of a contact person.
    */
    'contactPersonName'?: string;
    /**
    * This is an identifier related to this PartyInformation and their internal reference of the tender (or award). This might be used to assign an identifier (German \"Vergabenummer\") for the current project. This is typically only used in Buyer and Bidder representations and should map to the concept of \"Vergabenummer\" or \"AwardNo\" in GAEB.
    */
    'awardIdentifier'?: string;
    /**
    * This property indicates if the party is registered within the European Economic Area.
    */
    'isInEuropeanEconomicArea': boolean;
    /**
    * If this is within the European Economic Area (see IsInEuropeanEconomicArea, then as a business entity it likely has an EU VAT Id.
    */
    'vatId'?: string;
    /**
    * The fax number for this party.
    */
    'fax'?: string;
    /**
    * The two letter ISO country code, e.g. DE for Germany.
    */
    'countryCode'?: string;
    /**
    * Depending on which party this class represents, it might have either a 'creditor' or 'debtor' number. This is often used in internal accounting systems.
    */
    'creditorOrDebtorIdentifier'?: string;
    /**
    * The Global Location Number (GLN) is issued by GS1 and is intended to be a unique identifier for the physical address of a party, e.g. a business office.
    */
    'globalLocationNumber'?: string;
    /**
    * This list contains information about bank accounts associated with this PartyInformation. It's typically used for buyers and bidders.
    */
    'bankingInformation'?: Array<BankingInformationDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "zipCode",
            "baseName": "zipCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "remarks",
            "baseName": "remarks",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "contactPersonName",
            "baseName": "contactPersonName",
            "type": "string"
        },
        {
            "name": "awardIdentifier",
            "baseName": "awardIdentifier",
            "type": "string"
        },
        {
            "name": "isInEuropeanEconomicArea",
            "baseName": "isInEuropeanEconomicArea",
            "type": "boolean"
        },
        {
            "name": "vatId",
            "baseName": "vatId",
            "type": "string"
        },
        {
            "name": "fax",
            "baseName": "fax",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "creditorOrDebtorIdentifier",
            "baseName": "creditorOrDebtorIdentifier",
            "type": "string"
        },
        {
            "name": "globalLocationNumber",
            "baseName": "globalLocationNumber",
            "type": "string"
        },
        {
            "name": "bankingInformation",
            "baseName": "bankingInformation",
            "type": "Array<BankingInformationDto>"
        }    ];

    static getAttributeTypeMap() {
        return PartyInformationDto.attributeTypeMap;
    }
}

export class PositionDto extends IElementDto {
    /**
    * Will return the price per unit, rounded according to the project settings or the default value of three decimal places
    */
    'unitPrice': number;
    /**
    * You can use this property to directly set the unit price for this position. This will override any given PriceComponents
    */
    'unitPriceOverride'?: number;
    /**
    * Will return this Position's total quantity, rounded to three decimal places.
    */
    'quantity': number;
    /**
    * You can use this property to directly set the quantity for this position. This will override any given QuantityComponents
    */
    'quantityOverride'?: number;
    /**
    * The tag of the unit used for this positions quantity.
    */
    'unitTag'?: string;
    /**
    * The components for labour time in this Position.
    */
    'labourComponents'?: LabourPriceComponentDto;
    /**
    * The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation.
    */
    'priceComponents'?: Array<PriceComponentDto>;
    /**
    * The quantity components of this Position.
    */
    'quantityComponents'?: Array<CalculationDto>;
    /**
    * Further structuring of this Position.
    */
    'subDescriptions'?: Array<SubDescriptionDto>;
    /**
    * Indicates the status of this Position's comission.
    */
    'comissionStatus': ComissionStatusDto;
    /**
    * A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions.
    */
    'complementedBy'?: Array<string>;
    /**
    * Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property.
    */
    'complemented': boolean;
    /**
    * Indicates that the amount for this Position is to be set by the bidder.
    */
    'amountToBeEnteredByBidder': boolean;
    /**
    * Indicates if the bidder demands for prices to be broken up into their price components.
    */
    'priceCompositionRequired': boolean;
    /**
    * Indicates if this Position should use a different TaxRate than what is the default for the Project.
    */
    'useDifferentTaxRate': boolean;
    /**
    * Will return either the parent ServiceSpecification's TaxRate or it's own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions)
    */
    'taxRate': number;
    /**
    * The ItemNumber for this Position.
    */
    'itemNumber'?: ItemNumberDto;
    /**
    * The rate of deductions, i.e. 0.12m means 12% price deduction.
    */
    'deductionFactor': number;
    /**
    * Returns the product of UnitPrice times Quantity.
    */
    'totalPrice': number;
    /**
    * The total gross price for this Position.
    */
    'totalPriceGross': number;
    /**
    * Total gross price after applied deductions.
    */
    'totalPriceGrossDeducted': number;
    /**
    * Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position.
    */
    'deductedPrice': number;
    /**
    * This indicates the type of a position. If this is an alternative position, its AlternativeTo property should be set to the id of the position it can replace.
    */
    'positionType': PositionTypeDto;
    /**
    * Indicates the PriceType of this Position.
    */
    'priceType': PriceTypeDto;
    /**
    * This indicates if this position is regular or describing a labour / hourly paid work service
    */
    'serviceType': ServiceTypeDto;
    /**
    * This property describes additional information about a product being used within this Position. For example, a pipe position, per length unit, could be composed of different pipe segments, fitting and other accessory articles.
    */
    'productData'?: ProductDataDto;
    /**
    * Short description for this DescriptionBase element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    /**
    * Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.
    */
    'additionType': AdditionTypeDto;
    'elementType'?: string;
    /**
    * Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
    */
    'quantityAssignments'?: Array<QuantityAssignmentDto>;
    /**
    * The CommerceProperties support specialized information that is only useful in GAEB XML 9x data exchange phases. It is intended to provide article information.
    */
    'commerceProperties'?: CommercePropertiesDto;
    /**
    * If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position.
    */
    'alternativeTo'?: string;
    /**
    * This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
    */
    'alternativeIdentifier'?: number;
    /**
    * This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It's different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
    */
    'alternativeGroupIdentifier'?: number;
    /**
    * If this is true, it indicates that the position is intended to be a lump sum, \"Pauschal\" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used.
    */
    'isLumpSum': boolean;
    /**
    * This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches \"Bezugsposition\" in GAEB. This can be used for positions that repeat partially or are linked together
    */
    'repetitionTo'?: string;
    'type'?: string;
    /**
    * This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
    */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
    * This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it's up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here.
    */
    'complementedByQuantities'?: Array<ComplementedByQuantityDto>;
    /**
    * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details.
    */
    'executionDescriptionReference'?: string;
    /**
    * This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all.
    */
    'notOffered': boolean;
    /**
    * This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.
    */
    'oenormPositionProperties'?: OenormPositionPropertiesDto;
    /**
    * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.
    */
    'descriptionId'?: string;
    /**
    * This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
    */
    'hierarchyLevel': number;
    /**
    * This indicates, if this element is part of an addendum an, if yes, with what status.
    */
    'addendumStatus'?: AddendumStatusDto;
    'hasBidderCommentInHtmlLongText': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "number"
        },
        {
            "name": "unitPriceOverride",
            "baseName": "unitPriceOverride",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "quantityOverride",
            "baseName": "quantityOverride",
            "type": "number"
        },
        {
            "name": "unitTag",
            "baseName": "unitTag",
            "type": "string"
        },
        {
            "name": "labourComponents",
            "baseName": "labourComponents",
            "type": "LabourPriceComponentDto"
        },
        {
            "name": "priceComponents",
            "baseName": "priceComponents",
            "type": "Array<PriceComponentDto>"
        },
        {
            "name": "quantityComponents",
            "baseName": "quantityComponents",
            "type": "Array<CalculationDto>"
        },
        {
            "name": "subDescriptions",
            "baseName": "subDescriptions",
            "type": "Array<SubDescriptionDto>"
        },
        {
            "name": "comissionStatus",
            "baseName": "comissionStatus",
            "type": "ComissionStatusDto"
        },
        {
            "name": "complementedBy",
            "baseName": "complementedBy",
            "type": "Array<string>"
        },
        {
            "name": "complemented",
            "baseName": "complemented",
            "type": "boolean"
        },
        {
            "name": "amountToBeEnteredByBidder",
            "baseName": "amountToBeEnteredByBidder",
            "type": "boolean"
        },
        {
            "name": "priceCompositionRequired",
            "baseName": "priceCompositionRequired",
            "type": "boolean"
        },
        {
            "name": "useDifferentTaxRate",
            "baseName": "useDifferentTaxRate",
            "type": "boolean"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "number"
        },
        {
            "name": "itemNumber",
            "baseName": "itemNumber",
            "type": "ItemNumberDto"
        },
        {
            "name": "deductionFactor",
            "baseName": "deductionFactor",
            "type": "number"
        },
        {
            "name": "totalPrice",
            "baseName": "totalPrice",
            "type": "number"
        },
        {
            "name": "totalPriceGross",
            "baseName": "totalPriceGross",
            "type": "number"
        },
        {
            "name": "totalPriceGrossDeducted",
            "baseName": "totalPriceGrossDeducted",
            "type": "number"
        },
        {
            "name": "deductedPrice",
            "baseName": "deductedPrice",
            "type": "number"
        },
        {
            "name": "positionType",
            "baseName": "positionType",
            "type": "PositionTypeDto"
        },
        {
            "name": "priceType",
            "baseName": "priceType",
            "type": "PriceTypeDto"
        },
        {
            "name": "serviceType",
            "baseName": "serviceType",
            "type": "ServiceTypeDto"
        },
        {
            "name": "productData",
            "baseName": "productData",
            "type": "ProductDataDto"
        },
        {
            "name": "shortText",
            "baseName": "shortText",
            "type": "string"
        },
        {
            "name": "longText",
            "baseName": "longText",
            "type": "string"
        },
        {
            "name": "htmlLongText",
            "baseName": "htmlLongText",
            "type": "string"
        },
        {
            "name": "additionType",
            "baseName": "additionType",
            "type": "AdditionTypeDto"
        },
        {
            "name": "elementType",
            "baseName": "elementType",
            "type": "string"
        },
        {
            "name": "quantityAssignments",
            "baseName": "quantityAssignments",
            "type": "Array<QuantityAssignmentDto>"
        },
        {
            "name": "commerceProperties",
            "baseName": "commerceProperties",
            "type": "CommercePropertiesDto"
        },
        {
            "name": "alternativeTo",
            "baseName": "alternativeTo",
            "type": "string"
        },
        {
            "name": "alternativeIdentifier",
            "baseName": "alternativeIdentifier",
            "type": "number"
        },
        {
            "name": "alternativeGroupIdentifier",
            "baseName": "alternativeGroupIdentifier",
            "type": "number"
        },
        {
            "name": "isLumpSum",
            "baseName": "isLumpSum",
            "type": "boolean"
        },
        {
            "name": "repetitionTo",
            "baseName": "repetitionTo",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "standardizedDescription",
            "baseName": "standardizedDescription",
            "type": "StandardizedDescriptionDto"
        },
        {
            "name": "complementedByQuantities",
            "baseName": "complementedByQuantities",
            "type": "Array<ComplementedByQuantityDto>"
        },
        {
            "name": "executionDescriptionReference",
            "baseName": "executionDescriptionReference",
            "type": "string"
        },
        {
            "name": "notOffered",
            "baseName": "notOffered",
            "type": "boolean"
        },
        {
            "name": "oenormPositionProperties",
            "baseName": "oenormPositionProperties",
            "type": "OenormPositionPropertiesDto"
        },
        {
            "name": "descriptionId",
            "baseName": "descriptionId",
            "type": "string"
        },
        {
            "name": "hierarchyLevel",
            "baseName": "hierarchyLevel",
            "type": "number"
        },
        {
            "name": "addendumStatus",
            "baseName": "addendumStatus",
            "type": "AddendumStatusDto"
        },
        {
            "name": "hasBidderCommentInHtmlLongText",
            "baseName": "hasBidderCommentInHtmlLongText",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PositionDto.attributeTypeMap);
    }
}

/**
* This is a classification for Position elements.
*/
export class PositionTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PositionTypeDto.attributeTypeMap;
    }
}

/**
* Options for validating an AVA project
*/
export class PostAvaProjectValidationSourceOptions {
    /**
    * The project that should be validated
    */
    'avaProject': ProjectDto;
    /**
    * The index of the ServiceSpecification that should be validated. If not given, will default to the first one in the project.
    */
    'serviceSpecificationIndex'?: number;
    /**
    * This can optionally be specified to simulate a conversion to a specific target.
    */
    'validationType': ValidationType;
    /**
    * This can optionally be supplied to test for a specific exchange phase. For example, missing prices will only trigger errors in some specific exchange phases. Please note: If a conversion to a specific format, e.g. GAEB or ÖNorm, is given, this parameter is not applied to the internal conversion. The converter options must be set in the appropriate properties as well.
    */
    'exchangePhase'?: ExchangePhaseDto;
    /**
    * Options for importing the AVA project
    */
    'avaSourceOptions'?: PostAvaSourceOptions;
    /**
    * Options for conversion to Oenorm. Should be given if ValidationType is set to Oenorm.
    */
    'oenormDestinationOptions'?: PostOenormDestinationOptions;
    /**
    * Options for conversion to GAEB. Should be given if ValidationType is set to GAEB.
    */
    'gaebDestinationOptions'?: PostGaebDestinationOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avaProject",
            "baseName": "avaProject",
            "type": "ProjectDto"
        },
        {
            "name": "serviceSpecificationIndex",
            "baseName": "serviceSpecificationIndex",
            "type": "number"
        },
        {
            "name": "validationType",
            "baseName": "validationType",
            "type": "ValidationType"
        },
        {
            "name": "exchangePhase",
            "baseName": "exchangePhase",
            "type": "ExchangePhaseDto"
        },
        {
            "name": "avaSourceOptions",
            "baseName": "avaSourceOptions",
            "type": "PostAvaSourceOptions"
        },
        {
            "name": "oenormDestinationOptions",
            "baseName": "oenormDestinationOptions",
            "type": "PostOenormDestinationOptions"
        },
        {
            "name": "gaebDestinationOptions",
            "baseName": "gaebDestinationOptions",
            "type": "PostGaebDestinationOptions"
        }    ];

    static getAttributeTypeMap() {
        return PostAvaProjectValidationSourceOptions.attributeTypeMap;
    }
}

/**
* Options for conversions from AVA
*/
export class PostAvaSourceOptions {
    /**
    * If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
    */
    'tryAutoGenerateItemNumbersAndSchema': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tryAutoGenerateItemNumbersAndSchema",
            "baseName": "tryAutoGenerateItemNumbersAndSchema",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PostAvaSourceOptions.attributeTypeMap;
    }
}

/**
* Options for conversions to GAEB
*/
export class PostGaebDestinationOptions {
    /**
    * Defaults to GAEB XML V3.2
    */
    'destinationGaebType': DestinationGaebType;
    /**
    * Defaults to none, meaning no transformation will be done
    */
    'targetExchangePhaseTransform': DestinationGaebExchangePhase;
    /**
    * Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
    */
    'enforceStrictOfferPhaseLongTextOutput': boolean;
    /**
    * Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the 'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for 'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the 'QuantityComponents' property.
    */
    'exportQuantityDetermination': boolean;
    /**
    * If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
    */
    'removeUnprintableCharactersFromTexts': boolean;
    /**
    * If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
    */
    'forceIncludeDescriptions': boolean;
    /**
    * When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
    */
    'treatNullItemNumberSchemaAsInvalid': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "destinationGaebType",
            "baseName": "destinationGaebType",
            "type": "DestinationGaebType"
        },
        {
            "name": "targetExchangePhaseTransform",
            "baseName": "targetExchangePhaseTransform",
            "type": "DestinationGaebExchangePhase"
        },
        {
            "name": "enforceStrictOfferPhaseLongTextOutput",
            "baseName": "enforceStrictOfferPhaseLongTextOutput",
            "type": "boolean"
        },
        {
            "name": "exportQuantityDetermination",
            "baseName": "exportQuantityDetermination",
            "type": "boolean"
        },
        {
            "name": "removeUnprintableCharactersFromTexts",
            "baseName": "removeUnprintableCharactersFromTexts",
            "type": "boolean"
        },
        {
            "name": "forceIncludeDescriptions",
            "baseName": "forceIncludeDescriptions",
            "type": "boolean"
        },
        {
            "name": "treatNullItemNumberSchemaAsInvalid",
            "baseName": "treatNullItemNumberSchemaAsInvalid",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PostGaebDestinationOptions.attributeTypeMap;
    }
}

/**
* Options for conversions to Oenorm
*/
export class PostOenormDestinationOptions {
    /**
    * Defaults to Lv2015
    */
    'destinationOenormType': DestinationOenormType;
    /**
    * Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
    */
    'tryRepairProjectStructure': boolean;
    /**
    * If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
    */
    'skipTryEnforceSchemaCompliantXmlOutput': boolean;
    /**
    * If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
    */
    'removeUnprintableCharactersFromTexts': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "destinationOenormType",
            "baseName": "destinationOenormType",
            "type": "DestinationOenormType"
        },
        {
            "name": "tryRepairProjectStructure",
            "baseName": "tryRepairProjectStructure",
            "type": "boolean"
        },
        {
            "name": "skipTryEnforceSchemaCompliantXmlOutput",
            "baseName": "skipTryEnforceSchemaCompliantXmlOutput",
            "type": "boolean"
        },
        {
            "name": "removeUnprintableCharactersFromTexts",
            "baseName": "removeUnprintableCharactersFromTexts",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PostOenormDestinationOptions.attributeTypeMap;
    }
}

/**
* This class provides means to store information about a price and it's composition. Note that this is referencing to a single price component, so for example a Position would have a list of PriceComponents, one for Material, one for Labour etc.
*/
export class PriceComponentDto {
    /**
    * The total, calculated price of this component.
    */
    'price': number;
    /**
    * The label associated with this price component. Will be taken from the parent Projects ProjectInformation.
    */
    'label'?: string;
    /**
    * The single Calculation elements this price component is composed of.
    */
    'values'?: Array<CalculationDto>;
    /**
    * These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CalculationDto>"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        }    ];

    static getAttributeTypeMap() {
        return PriceComponentDto.attributeTypeMap;
    }
}

/**
* This enumeration models types of price components for better classification.
*/
export class PriceComponentTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PriceComponentTypeDto.attributeTypeMap;
    }
}

/**
* Holds global price information for a ServiceSpecification
*/
export class PriceInformationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The amount of currency per one hour of manual labour work in this project.
    */
    'hourlyWage': number;
    /**
    * The final, total price will be deducted by this rate.
    */
    'deductionFactor': number;
    /**
    * This is given when there is only one flat price for the whole service specification.
    */
    'flatSum': number;
    /**
    * Global tax rate for the project. Note that certain elements may have a different, specific tax rate.
    */
    'taxRate': number;
    /**
    * Trade discounts for offered in this ServiceSpecification.
    */
    'tradeDiscounts'?: Array<TradeDiscountDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "hourlyWage",
            "baseName": "hourlyWage",
            "type": "number"
        },
        {
            "name": "deductionFactor",
            "baseName": "deductionFactor",
            "type": "number"
        },
        {
            "name": "flatSum",
            "baseName": "flatSum",
            "type": "number"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "number"
        },
        {
            "name": "tradeDiscounts",
            "baseName": "tradeDiscounts",
            "type": "Array<TradeDiscountDto>"
        }    ];

    static getAttributeTypeMap() {
        return PriceInformationDto.attributeTypeMap;
    }
}

/**
* This enum configures rounding modes for price calculations in projects
*/
export class PriceRoundingModeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PriceRoundingModeDto.attributeTypeMap;
    }
}

/**
* This indicates the price type of a IPricedElement.
*/
export class PriceTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PriceTypeDto.attributeTypeMap;
    }
}

/**
* This class represents data about products and their vendor
*/
export class ProductDataDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This PartyInformation is used to describe details about the vendor of this ProductData.
    */
    'vendor'?: PartyInformationDto;
    /**
    * The collection of ArticleData that describe this product, e.g. a pipe product could be composed out of multiple pipe segments and fittings.
    */
    'articles'?: Array<ArticleDataDto>;
    /**
    * Short description for this ITextElement element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "PartyInformationDto"
        },
        {
            "name": "articles",
            "baseName": "articles",
            "type": "Array<ArticleDataDto>"
        },
        {
            "name": "shortText",
            "baseName": "shortText",
            "type": "string"
        },
        {
            "name": "longText",
            "baseName": "longText",
            "type": "string"
        },
        {
            "name": "htmlLongText",
            "baseName": "htmlLongText",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductDataDto.attributeTypeMap;
    }
}

/**
* A Project contains all relevant information for a construction project.
*/
export class ProjectDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This property controls the accuracy of all price properties, meaning how many decimal places are preserved in calculations. It defaults to DEFAULT_PRICE_ACCURACY. Please see the Dangl.AVA documentation for further information about decimal precision.
    */
    'priceAccuracy': number;
    /**
    * This forces total prices to be the strict product of quantities times unit price in positions. It is enabled by default. If this is disabled, both the unit price and the total price of positions is calculated from the non-rounded values. Please see the documentation for a more detailed explanation of this setting.
    */
    'forceStrictTotals': boolean;
    /**
    * This property controls the rounding mode of all price properties, meaning how rounding of decimal places is performed in price calculations. It defaults to DEFAULT_ROUNDING_MODE. Please see the Dangl.AVA documentation for further information about decimal precision.
    */
    'priceRoundingMode': PriceRoundingModeDto;
    /**
    * The ProjectInformation contains information that describes the project and its structure.
    */
    'projectInformation'?: ProjectInformationDto;
    /**
    * The ServiceSpecifications in this Project.
    */
    'serviceSpecifications'?: Array<ServiceSpecificationDto>;
    /**
    * This is used to store the GAEB XML Id within this Project. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "priceAccuracy",
            "baseName": "priceAccuracy",
            "type": "number"
        },
        {
            "name": "forceStrictTotals",
            "baseName": "forceStrictTotals",
            "type": "boolean"
        },
        {
            "name": "priceRoundingMode",
            "baseName": "priceRoundingMode",
            "type": "PriceRoundingModeDto"
        },
        {
            "name": "projectInformation",
            "baseName": "projectInformation",
            "type": "ProjectInformationDto"
        },
        {
            "name": "serviceSpecifications",
            "baseName": "serviceSpecifications",
            "type": "Array<ServiceSpecificationDto>"
        },
        {
            "name": "gaebXmlId",
            "baseName": "gaebXmlId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectDto.attributeTypeMap;
    }
}

/**
* General information about a Project.
*/
export class ProjectInformationDto {
    /**
    * Information about the buyer.
    */
    'buyer'?: PartyInformationDto;
    /**
    * Description for the project.
    */
    'description'?: string;
    /**
    * Short description for the project.
    */
    'descriptionShort'?: string;
    /**
    * Name of the project.
    */
    'name'?: string;
    /**
    * Information about the site.
    */
    'site'?: PartyInformationDto;
    /**
    * The ItemNumberSchema used in the project.
    */
    'itemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * Short label for the currency used.
    */
    'currencyShort'?: string;
    /**
    * Full label of the currency used.
    */
    'currencyLong'?: string;
    /**
    * Label for the labour time part of prices used in the project.
    */
    'labourTimeLabel'?: string;
    /**
    * Labels for the price components used in the project. Caution: Removal of a price component will trigger to have dependent price informations be deleted in IElements that use this property. If this property is changed or altered after the project has already been used, it is strongly advised to do operations step by step, e.g. if renaming and reordering multiple price components, this should be done one by one. Otherwise, a combination of rename and reordering will not be correctly propagated downwards to child objects in this Project.
    */
    'priceComponents'?: Array<string>;
    /**
    * This dictionary specifies actual types used for the PriceComponents. For example, a single price component might have the name 'Material' as a string, ans this dictionary would then have a key 'Material' and a value of Materials. You can not add keys here that are not also present in the PriceComponents property, and removing price components will also remove them from this dictionary here.
    */
    'priceComponentTypes'?: { [key: string]: PriceComponentTypeDto; };
    /**
    * This bool indicates if this project allows the bidder to add bidder comments. Bidder comments are a way to attach clarifying information when submitting an offer.
    */
    'bidderCommentAllowed': boolean;
    /**
    * This property indicates if the project should allow side offers from contractors. In GAEB, a side offer would typically be in exchange phase 85.
    */
    'sideOffersAllowed': boolean;
    /**
    * This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard
    */
    'awardType': AwardTypeDto;
    /**
    * This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary
    */
    'specialAwardKind': SpecialAwardKindDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "buyer",
            "baseName": "buyer",
            "type": "PartyInformationDto"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "site",
            "baseName": "site",
            "type": "PartyInformationDto"
        },
        {
            "name": "itemNumberSchema",
            "baseName": "itemNumberSchema",
            "type": "ItemNumberSchemaDto"
        },
        {
            "name": "currencyShort",
            "baseName": "currencyShort",
            "type": "string"
        },
        {
            "name": "currencyLong",
            "baseName": "currencyLong",
            "type": "string"
        },
        {
            "name": "labourTimeLabel",
            "baseName": "labourTimeLabel",
            "type": "string"
        },
        {
            "name": "priceComponents",
            "baseName": "priceComponents",
            "type": "Array<string>"
        },
        {
            "name": "priceComponentTypes",
            "baseName": "priceComponentTypes",
            "type": "{ [key: string]: PriceComponentTypeDto; }"
        },
        {
            "name": "bidderCommentAllowed",
            "baseName": "bidderCommentAllowed",
            "type": "boolean"
        },
        {
            "name": "sideOffersAllowed",
            "baseName": "sideOffersAllowed",
            "type": "boolean"
        },
        {
            "name": "awardType",
            "baseName": "awardType",
            "type": "AwardTypeDto"
        },
        {
            "name": "specialAwardKind",
            "baseName": "specialAwardKind",
            "type": "SpecialAwardKindDto"
        }    ];

    static getAttributeTypeMap() {
        return ProjectInformationDto.attributeTypeMap;
    }
}

/**
* Check details specificly for checking ProjectDto objects
*/
export class ProjectValidationCheckDetails {
    /**
    * The id of the element
    */
    'elementId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "elementId",
            "baseName": "elementId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectValidationCheckDetails.attributeTypeMap;
    }
}

/**
* Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of their parent Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
*/
export class QuantityAssignmentDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The total quantity in this quantity assignment
    */
    'quantity': number;
    /**
    * These are Catalogue that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * Referenced catalogues for this QuantityAssignment.
    */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        },
        {
            "name": "catalogueReferences",
            "baseName": "catalogueReferences",
            "type": "Array<CatalogueReferenceDto>"
        }    ];

    static getAttributeTypeMap() {
        return QuantityAssignmentDto.attributeTypeMap;
    }
}

export class RegisterPost {
    'username': string;
    'email': string;
    'password': string;
    'preferredLanguages'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "preferredLanguages",
            "baseName": "preferredLanguages",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RegisterPost.attributeTypeMap;
    }
}

/**
* 
*/
export class ResponseErrorType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ResponseErrorType.attributeTypeMap;
    }
}

/**
* This class represents a single key reference within the German STLB \"Standardleistungsbuch Bau\"
*/
export class STLBKeyDto {
    /**
    * This identifier is required and uniquely describes a single reference within the STLB standard. It maps to \"ArtChrIdent\" in GAEB XML
    */
    'artIdentifier': number;
    /**
    * This optional index property further categorizes a single reference within the STLB standard. It maps to \"ArtChIdx\" in GAEB XML
    */
    'artIndex'?: number;
    /**
    * This optional identifier further specifies the execution kind of the reference in the STLB standard. It maps to \"ChVIdent\" in GAEB XML
    */
    'kindIdentifier'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "artIdentifier",
            "baseName": "artIdentifier",
            "type": "number"
        },
        {
            "name": "artIndex",
            "baseName": "artIndex",
            "type": "number"
        },
        {
            "name": "kindIdentifier",
            "baseName": "kindIdentifier",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return STLBKeyDto.attributeTypeMap;
    }
}

/**
* This class represents a specialized reference to the German STLB \"Standardleistungsbuch Bau\". The STLB is a commercial offering and describes common services in the construction sector. When this is used, this describes the exact type of a service via a reference to this standard
*/
export class STLBReferenceDto {
    /**
    * The date of the STLB version. Typically, only the Year and Month are used
    */
    'versionDate'?: Date;
    /**
    * The name of the catalogue within the STLB
    */
    'catalogueName'?: string;
    /**
    * The name of the group in STLB
    */
    'group'?: string;
    /**
    * The cost group this service is associated with
    */
    'costGroup'?: string;
    /**
    * The service area (or type) in the STLB
    */
    'serviceArea'?: string;
    /**
    * These keys may optionally be used to further reference multiple, specific items within the STLB
    */
    'keys'?: Array<STLBKeyDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "versionDate",
            "baseName": "versionDate",
            "type": "Date"
        },
        {
            "name": "catalogueName",
            "baseName": "catalogueName",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "string"
        },
        {
            "name": "costGroup",
            "baseName": "costGroup",
            "type": "string"
        },
        {
            "name": "serviceArea",
            "baseName": "serviceArea",
            "type": "string"
        },
        {
            "name": "keys",
            "baseName": "keys",
            "type": "Array<STLBKeyDto>"
        }    ];

    static getAttributeTypeMap() {
        return STLBReferenceDto.attributeTypeMap;
    }
}

/**
* This is the base class that holds information about a whole service specification.
*/
export class ServiceSpecificationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectHourlyWage': number;
    /**
    * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectTaxRate': number;
    /**
    * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
    */
    'projectPriceComponents'?: Array<string>;
    /**
    * The ItemNumberSchema that is used within this project.
    */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * The IElements within this ElementContainerBase.
    */
    'elements'?: Array<IElementDto>;
    /**
    * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
    */
    'projectLabourTimeLabel'?: string;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateItemNumbers': boolean;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateElementIds': boolean;
    /**
    * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateItemNumbers': boolean;
    /**
    * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateElementIds': boolean;
    /**
    * Price composition by tax rate.
    */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
    * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
    */
    'ignoreChildPriceUpdates': boolean;
    /**
    * Net price after applied deductions.
    */
    'deductedPrice': number;
    /**
    * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
    */
    'deductionFactor': number;
    /**
    * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
    */
    'absoluteDeduction'?: number;
    /**
    * Will return this ElementContainerBase's total price.
    */
    'totalPrice': number;
    /**
    * The total gross price for this ElementContainerBase including all child elements.
    */
    'totalPriceGross': number;
    /**
    * Total gross price after applied deductions.
    */
    'totalPriceGrossDeducted': number;
    /**
    * Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not.
    */
    'priceType': PriceTypeDto;
    /**
    * Information about the bidder.
    */
    'bidder'?: PartyInformationDto;
    /**
    * This discriminator is used to identify different bidders in a project. It is different from the Identifier property in the Bidder in that the BidderDiscriminator is intended to be a numerical identifier within a project, while the Identifier does uniquely identify a bidder in the system independent of a specific project. This property should map to \"Bieternummer\" or \"BidderNo\" in GAEB.
    */
    'bidderDiscriminator'?: string;
    /**
    * This is used to store the GAEB XML Id within this ServiceSpecification. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    /**
    * The ProjectInformation used within the Project in which this ElementContainerBase is contained. This is reference equal to the ProjectInformation used in the parent project.
    */
    'projectInformation'?: ProjectInformationDto;
    /**
    * This service specifications exchange phase, i.e. the current status in the project it is intended to be used (such as request for offer, offer, awarding...).
    */
    'exchangePhase': ExchangePhaseDto;
    /**
    * This indicates where the service specification originates, i.e. from an exchange file format or self created. If applicable, additional information is present in the OriginDetail property.
    */
    'origin': OriginDto;
    /**
    * This property complements the Origin property. Some formats, e.g. GaebXml might have additional information attached, e.g. GAEB XML V3.2 oder GAEB XML V3.1. This string property is used to hold such data. The Dangl.AVA module does not have a list of possible values, since this is defined in the native format assemblies, e.g. Dangl.GAEB or Dangl.Oenorm.
    */
    'originDetail'?: string;
    /**
    * Creation date of this ServiceSpecification.
    */
    'creationDate'?: Date;
    /**
    * Date indicating until when an offer has to be submitted. In German, this is often called the \"Eröffnungstermin\"
    */
    'offerByDate'?: Date;
    /**
    * Date indicating by when the buyer will select a contractor.
    */
    'decisionDate'?: Date;
    /**
    * String indicating where the physical submission of the offer is taking place.
    */
    'submissionLocation'?: string;
    /**
    * Description of this ServiceSpecification.
    */
    'description'?: string;
    /**
    * The name of this ServiceSpecification.
    */
    'name'?: string;
    /**
    * This PriceInformation contains global data for the ServiceSpecification. When inside a Project, do not set this property manually.
    */
    'priceInformation'?: PriceInformationDto;
    /**
    * These are Catalogue that are used within this ElementContainerBase. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * Referenced catalogues for this ElementContainerBase.
    */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    /**
    * The date when the execution of the services is scheduled to start
    */
    'plannedExecutionStart'?: Date;
    /**
    * The date then the execution of the services is scheduled to be finished
    */
    'plannedExecutionEnd'?: Date;
    /**
    * The date on which the contract has been awarded. This matches \"Auftragsdatum\" in GAEB
    */
    'contractDate'?: Date;
    /**
    * This value can be used to indicate the number or identifier of the contract. It matches \"Auftragsnummer\" in GAEB
    */
    'contractIdentifier'?: string;
    /**
    * This indicates how long the warranty period is for this ServiceSpecification
    */
    'warrantyDuration'?: WarrantyDurationDto;
    /**
    * The date on which the warranty period ends
    */
    'warrantyEnd'?: Date;
    /**
    * The date on which the services rendered by the bidder are scheduled to be approved by the buyer
    */
    'approvalDate'?: Date;
    /**
    * This should specify how the approval is performed by the buyer. This matches \"AcceptType\" in GAEB
    */
    'typeOfApproval'?: string;
    /**
    * This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German.
    */
    'addendumNumber'?: string;
    /**
    * This indicates, if this element is part of an addendum an, if yes, with what status.
    */
    'addendumStatus'?: AddendumStatusDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projectHourlyWage",
            "baseName": "projectHourlyWage",
            "type": "number"
        },
        {
            "name": "projectTaxRate",
            "baseName": "projectTaxRate",
            "type": "number"
        },
        {
            "name": "projectPriceComponents",
            "baseName": "projectPriceComponents",
            "type": "Array<string>"
        },
        {
            "name": "projectItemNumberSchema",
            "baseName": "projectItemNumberSchema",
            "type": "ItemNumberSchemaDto"
        },
        {
            "name": "elements",
            "baseName": "elements",
            "type": "Array<IElementDto>"
        },
        {
            "name": "projectLabourTimeLabel",
            "baseName": "projectLabourTimeLabel",
            "type": "string"
        },
        {
            "name": "containsDuplicateItemNumbers",
            "baseName": "containsDuplicateItemNumbers",
            "type": "boolean"
        },
        {
            "name": "containsDuplicateElementIds",
            "baseName": "containsDuplicateElementIds",
            "type": "boolean"
        },
        {
            "name": "ignoreDuplicateItemNumbers",
            "baseName": "ignoreDuplicateItemNumbers",
            "type": "boolean"
        },
        {
            "name": "ignoreDuplicateElementIds",
            "baseName": "ignoreDuplicateElementIds",
            "type": "boolean"
        },
        {
            "name": "totalPriceGrossByTaxRate",
            "baseName": "totalPriceGrossByTaxRate",
            "type": "Array<GrossPriceComponentDto>"
        },
        {
            "name": "ignoreChildPriceUpdates",
            "baseName": "ignoreChildPriceUpdates",
            "type": "boolean"
        },
        {
            "name": "deductedPrice",
            "baseName": "deductedPrice",
            "type": "number"
        },
        {
            "name": "deductionFactor",
            "baseName": "deductionFactor",
            "type": "number"
        },
        {
            "name": "absoluteDeduction",
            "baseName": "absoluteDeduction",
            "type": "number"
        },
        {
            "name": "totalPrice",
            "baseName": "totalPrice",
            "type": "number"
        },
        {
            "name": "totalPriceGross",
            "baseName": "totalPriceGross",
            "type": "number"
        },
        {
            "name": "totalPriceGrossDeducted",
            "baseName": "totalPriceGrossDeducted",
            "type": "number"
        },
        {
            "name": "priceType",
            "baseName": "priceType",
            "type": "PriceTypeDto"
        },
        {
            "name": "bidder",
            "baseName": "bidder",
            "type": "PartyInformationDto"
        },
        {
            "name": "bidderDiscriminator",
            "baseName": "bidderDiscriminator",
            "type": "string"
        },
        {
            "name": "gaebXmlId",
            "baseName": "gaebXmlId",
            "type": "string"
        },
        {
            "name": "projectInformation",
            "baseName": "projectInformation",
            "type": "ProjectInformationDto"
        },
        {
            "name": "exchangePhase",
            "baseName": "exchangePhase",
            "type": "ExchangePhaseDto"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "OriginDto"
        },
        {
            "name": "originDetail",
            "baseName": "originDetail",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "Date"
        },
        {
            "name": "offerByDate",
            "baseName": "offerByDate",
            "type": "Date"
        },
        {
            "name": "decisionDate",
            "baseName": "decisionDate",
            "type": "Date"
        },
        {
            "name": "submissionLocation",
            "baseName": "submissionLocation",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priceInformation",
            "baseName": "priceInformation",
            "type": "PriceInformationDto"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        },
        {
            "name": "catalogueReferences",
            "baseName": "catalogueReferences",
            "type": "Array<CatalogueReferenceDto>"
        },
        {
            "name": "plannedExecutionStart",
            "baseName": "plannedExecutionStart",
            "type": "Date"
        },
        {
            "name": "plannedExecutionEnd",
            "baseName": "plannedExecutionEnd",
            "type": "Date"
        },
        {
            "name": "contractDate",
            "baseName": "contractDate",
            "type": "Date"
        },
        {
            "name": "contractIdentifier",
            "baseName": "contractIdentifier",
            "type": "string"
        },
        {
            "name": "warrantyDuration",
            "baseName": "warrantyDuration",
            "type": "WarrantyDurationDto"
        },
        {
            "name": "warrantyEnd",
            "baseName": "warrantyEnd",
            "type": "Date"
        },
        {
            "name": "approvalDate",
            "baseName": "approvalDate",
            "type": "Date"
        },
        {
            "name": "typeOfApproval",
            "baseName": "typeOfApproval",
            "type": "string"
        },
        {
            "name": "addendumNumber",
            "baseName": "addendumNumber",
            "type": "string"
        },
        {
            "name": "addendumStatus",
            "baseName": "addendumStatus",
            "type": "AddendumStatusDto"
        }    ];

    static getAttributeTypeMap() {
        return ServiceSpecificationDto.attributeTypeMap;
    }
}

export class ServiceSpecificationGroupDto extends IElementDto {
    /**
    * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectHourlyWage': number;
    /**
    * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectTaxRate': number;
    /**
    * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
    */
    'projectPriceComponents'?: Array<string>;
    /**
    * The ItemNumberSchema that is used within this project.
    */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * The IElements within this ElementContainerBase.
    */
    'elements'?: Array<IElementDto>;
    /**
    * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
    */
    'projectLabourTimeLabel'?: string;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateItemNumbers': boolean;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateElementIds': boolean;
    /**
    * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateItemNumbers': boolean;
    /**
    * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateElementIds': boolean;
    /**
    * Price composition by tax rate.
    */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
    * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
    */
    'ignoreChildPriceUpdates': boolean;
    /**
    * Net price after applied deductions.
    */
    'deductedPrice': number;
    /**
    * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
    */
    'deductionFactor': number;
    /**
    * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
    */
    'absoluteDeduction'?: number;
    /**
    * Will return this ElementContainerBase's total price.
    */
    'totalPrice': number;
    /**
    * The total gross price for this ElementContainerBase including all child elements.
    */
    'totalPriceGross': number;
    /**
    * Total gross price after applied deductions.
    */
    'totalPriceGrossDeducted': number;
    /**
    * Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not.
    */
    'priceType': PriceTypeDto;
    /**
    * Description for this ServiceSpecificationGroup.
    */
    'shortText'?: string;
    /**
    * Indicates if this service specification group is commissioned (and therefore should be executed), postponed for later or undefined.
    */
    'comissionStatus': ComissionStatusDto;
    /**
    * The ItemNumber for this INumberedElement interface.
    */
    'itemNumber'?: ItemNumberDto;
    'elementType'?: string;
    /**
    * This indicates if this group is the parent of a lot. See the documentation for more information about working with lots.
    */
    'isLot': boolean;
    /**
    * If this group is an alternative for a base group, then this property should point to the id of the group in this service specification that it can replace. If this is an alternative group to a base group, the PriceType should typically be set to \"WithoutTotal\" so this group does not factor into total costs. The PriceType is not changed when this property is set
    */
    'alternativeTo'?: string;
    'type'?: string;
    /**
    * This class models special properties that only apply to some exchange scenarios where ÖNorm is used.
    */
    'oenormProperties'?: OenormPropertiesDto;
    /**
    * This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
    */
    'hierarchyLevel': number;
    /**
    * This indicates, if this element is part of an addendum an, if yes, with what status.
    */
    'addendumStatus'?: AddendumStatusDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projectHourlyWage",
            "baseName": "projectHourlyWage",
            "type": "number"
        },
        {
            "name": "projectTaxRate",
            "baseName": "projectTaxRate",
            "type": "number"
        },
        {
            "name": "projectPriceComponents",
            "baseName": "projectPriceComponents",
            "type": "Array<string>"
        },
        {
            "name": "projectItemNumberSchema",
            "baseName": "projectItemNumberSchema",
            "type": "ItemNumberSchemaDto"
        },
        {
            "name": "elements",
            "baseName": "elements",
            "type": "Array<IElementDto>"
        },
        {
            "name": "projectLabourTimeLabel",
            "baseName": "projectLabourTimeLabel",
            "type": "string"
        },
        {
            "name": "containsDuplicateItemNumbers",
            "baseName": "containsDuplicateItemNumbers",
            "type": "boolean"
        },
        {
            "name": "containsDuplicateElementIds",
            "baseName": "containsDuplicateElementIds",
            "type": "boolean"
        },
        {
            "name": "ignoreDuplicateItemNumbers",
            "baseName": "ignoreDuplicateItemNumbers",
            "type": "boolean"
        },
        {
            "name": "ignoreDuplicateElementIds",
            "baseName": "ignoreDuplicateElementIds",
            "type": "boolean"
        },
        {
            "name": "totalPriceGrossByTaxRate",
            "baseName": "totalPriceGrossByTaxRate",
            "type": "Array<GrossPriceComponentDto>"
        },
        {
            "name": "ignoreChildPriceUpdates",
            "baseName": "ignoreChildPriceUpdates",
            "type": "boolean"
        },
        {
            "name": "deductedPrice",
            "baseName": "deductedPrice",
            "type": "number"
        },
        {
            "name": "deductionFactor",
            "baseName": "deductionFactor",
            "type": "number"
        },
        {
            "name": "absoluteDeduction",
            "baseName": "absoluteDeduction",
            "type": "number"
        },
        {
            "name": "totalPrice",
            "baseName": "totalPrice",
            "type": "number"
        },
        {
            "name": "totalPriceGross",
            "baseName": "totalPriceGross",
            "type": "number"
        },
        {
            "name": "totalPriceGrossDeducted",
            "baseName": "totalPriceGrossDeducted",
            "type": "number"
        },
        {
            "name": "priceType",
            "baseName": "priceType",
            "type": "PriceTypeDto"
        },
        {
            "name": "shortText",
            "baseName": "shortText",
            "type": "string"
        },
        {
            "name": "comissionStatus",
            "baseName": "comissionStatus",
            "type": "ComissionStatusDto"
        },
        {
            "name": "itemNumber",
            "baseName": "itemNumber",
            "type": "ItemNumberDto"
        },
        {
            "name": "elementType",
            "baseName": "elementType",
            "type": "string"
        },
        {
            "name": "isLot",
            "baseName": "isLot",
            "type": "boolean"
        },
        {
            "name": "alternativeTo",
            "baseName": "alternativeTo",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "oenormProperties",
            "baseName": "oenormProperties",
            "type": "OenormPropertiesDto"
        },
        {
            "name": "hierarchyLevel",
            "baseName": "hierarchyLevel",
            "type": "number"
        },
        {
            "name": "addendumStatus",
            "baseName": "addendumStatus",
            "type": "AddendumStatusDto"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ServiceSpecificationGroupDto.attributeTypeMap);
    }
}

/**
* The service type describes the type of service a Position represents.
*/
export class ServiceTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ServiceTypeDto.attributeTypeMap;
    }
}

/**
* This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary
*/
export class SpecialAwardKindDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SpecialAwardKindDto.attributeTypeMap;
    }
}

/**
* This enumeration identifies a pre-known standard used for referencing standardized descriptions.
*/
export class StandardReferenceTypeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return StandardReferenceTypeDto.attributeTypeMap;
    }
}

/**
* This class represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
*/
export class StandardizedDescriptionDto {
    /**
    * This enumeration identifies a pre-known standard used for referencing standardized descriptions.
    */
    'standardReferenceType': StandardReferenceTypeDto;
    /**
    * This string property is the identifier to map to the references standard. Its type is given in the StandardReferenceType
    */
    'standardReference'?: string;
    /**
    * This is a special reference to the German STLB \"Standardleistungsbuch Bau\" reference. If this is used, the StandardReference property should not be set.
    */
    'stlbReference'?: STLBReferenceDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "standardReferenceType",
            "baseName": "standardReferenceType",
            "type": "StandardReferenceTypeDto"
        },
        {
            "name": "standardReference",
            "baseName": "standardReference",
            "type": "string"
        },
        {
            "name": "stlbReference",
            "baseName": "stlbReference",
            "type": "STLBReferenceDto"
        }    ];

    static getAttributeTypeMap() {
        return StandardizedDescriptionDto.attributeTypeMap;
    }
}

/**
* This is appended to a Position and is used to separate the complete Position into smaller amounts to be described separately, for example concrete walls could be attached to different building storeys.
*/
export class SubDescriptionDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * Returns the total calculated sum of all quantity assignments. Will return the result rounded to three decimal places.
    */
    'quantity': number;
    /**
    * You can use this property to directly set the quantity for this sub description. This will override any given QuantityComponents
    */
    'quantityOverride'?: number;
    /**
    * Holds quantity information for this sub description. Quantity is listening to changes here and is reporting the total sum of all quantity components.
    */
    'quantityComponents'?: Array<CalculationDto>;
    /**
    * Indicates if the bidder is asked to specify an amount.
    */
    'amountToBeEnteredByBidder': boolean;
    /**
    * Identifier for this SubDescription.
    */
    'identifier'?: string;
    /**
    * Short description for this DescriptionBase element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * If this is given, then the sub description has a different unit tag than the parent position.
    */
    'unitTag'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    /**
    * Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.
    */
    'additionType': AdditionTypeDto;
    /**
    * This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
    */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
    * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions (or sub descriptions) should be executed in practice. Often, the position (or sub description) itself still has text of its own to highlight deviations from that or add more details. When working with import and export features, this property is only supported in GAEB 90 data exchange.
    */
    'executionDescriptionReference'?: string;
    /**
    * These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.
    */
    'descriptionId'?: string;
    'hasBidderCommentInHtmlLongText': boolean;
    'elementType'?: string;
    'elementTypeDiscriminator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "quantityOverride",
            "baseName": "quantityOverride",
            "type": "number"
        },
        {
            "name": "quantityComponents",
            "baseName": "quantityComponents",
            "type": "Array<CalculationDto>"
        },
        {
            "name": "amountToBeEnteredByBidder",
            "baseName": "amountToBeEnteredByBidder",
            "type": "boolean"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "shortText",
            "baseName": "shortText",
            "type": "string"
        },
        {
            "name": "longText",
            "baseName": "longText",
            "type": "string"
        },
        {
            "name": "unitTag",
            "baseName": "unitTag",
            "type": "string"
        },
        {
            "name": "htmlLongText",
            "baseName": "htmlLongText",
            "type": "string"
        },
        {
            "name": "additionType",
            "baseName": "additionType",
            "type": "AdditionTypeDto"
        },
        {
            "name": "standardizedDescription",
            "baseName": "standardizedDescription",
            "type": "StandardizedDescriptionDto"
        },
        {
            "name": "executionDescriptionReference",
            "baseName": "executionDescriptionReference",
            "type": "string"
        },
        {
            "name": "projectCatalogues",
            "baseName": "projectCatalogues",
            "type": "Array<CatalogueDto>"
        },
        {
            "name": "descriptionId",
            "baseName": "descriptionId",
            "type": "string"
        },
        {
            "name": "hasBidderCommentInHtmlLongText",
            "baseName": "hasBidderCommentInHtmlLongText",
            "type": "boolean"
        },
        {
            "name": "elementType",
            "baseName": "elementType",
            "type": "string"
        },
        {
            "name": "elementTypeDiscriminator",
            "baseName": "elementTypeDiscriminator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubDescriptionDto.attributeTypeMap;
    }
}

export class TokenLoginPost {
    'identifier': string;
    'password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TokenLoginPost.attributeTypeMap;
    }
}

export class TokenRefreshPost {
    'refreshToken': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "refreshToken",
            "baseName": "refreshToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TokenRefreshPost.attributeTypeMap;
    }
}

export class TokenResponseGet {
    'accessToken'?: string;
    'error'?: string;
    'errorDescription'?: string;
    'expiresIn': number;
    'httpErrorReason'?: string;
    'httpStatusCode': HttpStatusCode;
    'identityToken'?: string;
    'isError': boolean;
    'refreshToken'?: string;
    'tokenType'?: string;
    'errorType': ResponseErrorType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "errorDescription",
            "baseName": "errorDescription",
            "type": "string"
        },
        {
            "name": "expiresIn",
            "baseName": "expiresIn",
            "type": "number"
        },
        {
            "name": "httpErrorReason",
            "baseName": "httpErrorReason",
            "type": "string"
        },
        {
            "name": "httpStatusCode",
            "baseName": "httpStatusCode",
            "type": "HttpStatusCode"
        },
        {
            "name": "identityToken",
            "baseName": "identityToken",
            "type": "string"
        },
        {
            "name": "isError",
            "baseName": "isError",
            "type": "boolean"
        },
        {
            "name": "refreshToken",
            "baseName": "refreshToken",
            "type": "string"
        },
        {
            "name": "tokenType",
            "baseName": "tokenType",
            "type": "string"
        },
        {
            "name": "errorType",
            "baseName": "errorType",
            "type": "ResponseErrorType"
        }    ];

    static getAttributeTypeMap() {
        return TokenResponseGet.attributeTypeMap;
    }
}

/**
* This class holds information about offered trade discounts (Skonto in German)
*/
export class TradeDiscountDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The amount of days for how long a declared trade discount applies. Must be a positive number, negative values will be ignored and not set.
    */
    'deadline': number;
    /**
    * The rate of the trade discount.
    */
    'rate': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "deadline",
            "baseName": "deadline",
            "type": "number"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TradeDiscountDto.attributeTypeMap;
    }
}

/**
* This class models the results of a single check performed during a validation action
*/
export class ValidationCheckResult {
    /**
    * The severity for this check. Usually, low severity checks do not impact data exchange with third party applications
    */
    'severity': ValidationSeverity;
    /**
    * The actual check that is represented by this result. Additional information may be found in other properties of this class, depending on the check.
    */
    'checkType': ValidationCheckType;
    /**
    * A human readable message describing the result of the check.
    */
    'message'?: string;
    /**
    * For CheckType of types ObjectValidation
    */
    'objectValidationCheckDetails'?: ObjectValidationCheckDetails;
    /**
    * For CheckType of types XmlSchemaCheck
    */
    'xmlSchemaValidationCheckDetails'?: XmlSchemaValidationCheckDetails;
    /**
    * For CheckType of types ProjectValidation
    */
    'projectValidationCheckDetails'?: ProjectValidationCheckDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "severity",
            "baseName": "severity",
            "type": "ValidationSeverity"
        },
        {
            "name": "checkType",
            "baseName": "checkType",
            "type": "ValidationCheckType"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "objectValidationCheckDetails",
            "baseName": "objectValidationCheckDetails",
            "type": "ObjectValidationCheckDetails"
        },
        {
            "name": "xmlSchemaValidationCheckDetails",
            "baseName": "xmlSchemaValidationCheckDetails",
            "type": "XmlSchemaValidationCheckDetails"
        },
        {
            "name": "projectValidationCheckDetails",
            "baseName": "projectValidationCheckDetails",
            "type": "ProjectValidationCheckDetails"
        }    ];

    static getAttributeTypeMap() {
        return ValidationCheckResult.attributeTypeMap;
    }
}

/**
* Enumeration for the different types of checks performed
*/
export class ValidationCheckType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ValidationCheckType.attributeTypeMap;
    }
}

/**
* This class represents the result of a validation operation
*/
export class ValidationResult {
    /**
    * Indicates if the validation produced no errors
    */
    'isSchemaCompliant': boolean;
    /**
    * List of validation check results, which are usually errors
    */
    'checkResults'?: Array<ValidationCheckResult>;
    /**
    * The type of the validation that was performed
    */
    'validationType': ValidationType;
    /**
    * Name of the validated file
    */
    'fileName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isSchemaCompliant",
            "baseName": "isSchemaCompliant",
            "type": "boolean"
        },
        {
            "name": "checkResults",
            "baseName": "checkResults",
            "type": "Array<ValidationCheckResult>"
        },
        {
            "name": "validationType",
            "baseName": "validationType",
            "type": "ValidationType"
        },
        {
            "name": "fileName",
            "baseName": "fileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ValidationResult.attributeTypeMap;
    }
}

/**
* Indicates the severity of a check
*/
export class ValidationSeverity {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ValidationSeverity.attributeTypeMap;
    }
}

/**
* This enumeration represents the possible conversion targets when performing a validation
*/
export class ValidationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ValidationType.attributeTypeMap;
    }
}

/**
* This class does not represent a typical `TimeSpan` but has a scalar value int Duration and a DurationUnit Unit to represent durations as typically used in contracts, e.g. 5 Months
*/
export class WarrantyDurationDto {
    /**
    * The scalar value of the duration. This value must be equal to or bigger than zero (>= 0). Negative values can not be set and will be ignored.
    */
    'duration': number;
    /**
    * The unit of the duration
    */
    'unit': DurationUnitDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "unit",
            "baseName": "unit",
            "type": "DurationUnitDto"
        }    ];

    static getAttributeTypeMap() {
        return WarrantyDurationDto.attributeTypeMap;
    }
}

/**
* Check details for an XML schema validation result
*/
export class XmlSchemaValidationCheckDetails {
    /**
    * The line number on which the validation happened
    */
    'lineNumber': number;
    /**
    * The position in the line
    */
    'linePosition': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lineNumber",
            "baseName": "lineNumber",
            "type": "number"
        },
        {
            "name": "linePosition",
            "baseName": "linePosition",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return XmlSchemaValidationCheckDetails.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "AddendumStatusDto": AddendumStatusDto,
    "AdditionTypeDto": AdditionTypeDto,
    "ApiError": ApiError,
    "ArticleDataDto": ArticleDataDto,
    "AwardTypeDto": AwardTypeDto,
    "BankingInformationDto": BankingInformationDto,
    "CalculationDto": CalculationDto,
    "CatalogueDto": CatalogueDto,
    "CatalogueReferenceDto": CatalogueReferenceDto,
    "CatalogueTypeDto": CatalogueTypeDto,
    "ComissionStatusDto": ComissionStatusDto,
    "CommercePropertiesDto": CommercePropertiesDto,
    "ComplementedByQuantityDto": ComplementedByQuantityDto,
    "DestinationGaebExchangePhase": DestinationGaebExchangePhase,
    "DestinationGaebType": DestinationGaebType,
    "DestinationOenormType": DestinationOenormType,
    "DestinationRebType": DestinationRebType,
    "DurationUnitDto": DurationUnitDto,
    "ExchangePhaseDto": ExchangePhaseDto,
    "ExecutionDescriptionDto": ExecutionDescriptionDto,
    "FileValidationSourceType": FileValidationSourceType,
    "ForgotPasswordPost": ForgotPasswordPost,
    "GetStatus": GetStatus,
    "GrossPriceComponentDto": GrossPriceComponentDto,
    "HttpStatusCode": HttpStatusCode,
    "IElementDto": IElementDto,
    "ItemNumberDto": ItemNumberDto,
    "ItemNumberSchemaDto": ItemNumberSchemaDto,
    "ItemNumberSchemaTierDto": ItemNumberSchemaTierDto,
    "ItemNumberSchemaTierTypeDto": ItemNumberSchemaTierTypeDto,
    "ItemNumberTypeDto": ItemNumberTypeDto,
    "LabourPriceComponentDto": LabourPriceComponentDto,
    "LoginPost": LoginPost,
    "NoteTextDto": NoteTextDto,
    "ObjectValidationCheckDetails": ObjectValidationCheckDetails,
    "OenormNoteTextPropertiesDto": OenormNoteTextPropertiesDto,
    "OenormOriginCodeDto": OenormOriginCodeDto,
    "OenormPositionPropertiesDto": OenormPositionPropertiesDto,
    "OenormPropertiesDto": OenormPropertiesDto,
    "OriginDto": OriginDto,
    "PartyInformationDto": PartyInformationDto,
    "PositionDto": PositionDto,
    "PositionTypeDto": PositionTypeDto,
    "PostAvaProjectValidationSourceOptions": PostAvaProjectValidationSourceOptions,
    "PostAvaSourceOptions": PostAvaSourceOptions,
    "PostGaebDestinationOptions": PostGaebDestinationOptions,
    "PostOenormDestinationOptions": PostOenormDestinationOptions,
    "PriceComponentDto": PriceComponentDto,
    "PriceComponentTypeDto": PriceComponentTypeDto,
    "PriceInformationDto": PriceInformationDto,
    "PriceRoundingModeDto": PriceRoundingModeDto,
    "PriceTypeDto": PriceTypeDto,
    "ProductDataDto": ProductDataDto,
    "ProjectDto": ProjectDto,
    "ProjectInformationDto": ProjectInformationDto,
    "ProjectValidationCheckDetails": ProjectValidationCheckDetails,
    "QuantityAssignmentDto": QuantityAssignmentDto,
    "RegisterPost": RegisterPost,
    "ResponseErrorType": ResponseErrorType,
    "STLBKeyDto": STLBKeyDto,
    "STLBReferenceDto": STLBReferenceDto,
    "ServiceSpecificationDto": ServiceSpecificationDto,
    "ServiceSpecificationGroupDto": ServiceSpecificationGroupDto,
    "ServiceTypeDto": ServiceTypeDto,
    "SpecialAwardKindDto": SpecialAwardKindDto,
    "StandardReferenceTypeDto": StandardReferenceTypeDto,
    "StandardizedDescriptionDto": StandardizedDescriptionDto,
    "SubDescriptionDto": SubDescriptionDto,
    "TokenLoginPost": TokenLoginPost,
    "TokenRefreshPost": TokenRefreshPost,
    "TokenResponseGet": TokenResponseGet,
    "TradeDiscountDto": TradeDiscountDto,
    "ValidationCheckResult": ValidationCheckResult,
    "ValidationCheckType": ValidationCheckType,
    "ValidationResult": ValidationResult,
    "ValidationSeverity": ValidationSeverity,
    "ValidationType": ValidationType,
    "WarrantyDurationDto": WarrantyDurationDto,
    "XmlSchemaValidationCheckDetails": XmlSchemaValidationCheckDetails,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AslvConversionApiApiKeys {
}

export class AslvConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AslvConversionApiApiKeys, value: string) {
        (this.authentications as any)[AslvConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts Aslv files to Dangl.AVA projects
     * @param aslvFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public aslvConversionConvertToAva (aslvFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/aslv/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Aslv files to Excel
     * @param aslvFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public aslvConversionConvertToExcel (aslvFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/aslv/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Aslv files to GAEB files
     * @param aslvFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public aslvConversionConvertToGaeb (aslvFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/aslv/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Aslv files to Oenorm files
     * @param aslvFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public aslvConversionConvertToOenorm (aslvFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/aslv/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AvaConversionApiApiKeys {
}

export class AvaConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AvaConversionApiApiKeys, value: string) {
        (this.authentications as any)[AvaConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public avaConversionConvertToAva (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/ava/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToAva.');
        }

        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: avaProject
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Dangl.AVA projects to Excel
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public avaConversionConvertToExcel (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/ava/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToExcel.');
        }

        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Dangl.AVA projects to GAEB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public avaConversionConvertToGaeb (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/ava/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToGaeb.');
        }

        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Dangl.AVA projects to Oenorm
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public avaConversionConvertToOenorm (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/ava/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToOenorm.');
        }

        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Dangl.AVA projects to REB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationRebType Defaults to D11
     * @param {*} [options] Override http request options.
     */
    public avaConversionConvertToReb (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationRebType?: 'D11' | 'X31GaebXmlV32', options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/ava/reb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToReb.');
        }

        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }

        if (destinationRebType !== undefined) {
            localVarQueryParameters['DestinationRebType'] = ObjectSerializer.serialize(destinationRebType, "'D11' | 'X31GaebXmlV32'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Dangl.AVA projects to SIA 451
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {*} [options] Override http request options.
     */
    public avaConversionConvertToSia (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/ava/sia';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToSia.');
        }

        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DanglIdentityApiApiKeys {
}

export class DanglIdentityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DanglIdentityApiApiKeys, value: string) {
        (this.authentications as any)[DanglIdentityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public danglIdentityLoginAndReturnToken (model: TokenLoginPost, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TokenResponseGet;  }> {
        const localVarPath = this.basePath + '/identity/token-login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling danglIdentityLoginAndReturnToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "TokenLoginPost")
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TokenResponseGet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TokenResponseGet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param redirectUrl 
     * @param {*} [options] Override http request options.
     */
    public danglIdentityLoginWithCookie (model: LoginPost, redirectUrl?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/identity/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling danglIdentityLoginWithCookie.');
        }

        if (redirectUrl !== undefined) {
            localVarQueryParameters['redirectUrl'] = ObjectSerializer.serialize(redirectUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "LoginPost")
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public danglIdentityRefreshToken (model: TokenRefreshPost, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TokenResponseGet;  }> {
        const localVarPath = this.basePath + '/identity/token-refresh';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling danglIdentityRefreshToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "TokenRefreshPost")
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TokenResponseGet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TokenResponseGet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param registerModel 
     * @param {*} [options] Override http request options.
     */
    public danglIdentityRegister (registerModel: RegisterPost, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/identity/register';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'registerModel' is not null or undefined
        if (registerModel === null || registerModel === undefined) {
            throw new Error('Required parameter registerModel was null or undefined when calling danglIdentityRegister.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registerModel, "RegisterPost")
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param forgotPasswordModel 
     * @param {*} [options] Override http request options.
     */
    public danglIdentityRequestPasswordReset (forgotPasswordModel: ForgotPasswordPost, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/identity/password-forgotten';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'forgotPasswordModel' is not null or undefined
        if (forgotPasswordModel === null || forgotPasswordModel === undefined) {
            throw new Error('Required parameter forgotPasswordModel was null or undefined when calling danglIdentityRequestPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(forgotPasswordModel, "ForgotPasswordPost")
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public danglIdentitySignOutWithSignInManager (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/identity/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExcelConversionApiApiKeys {
}

export class ExcelConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExcelConversionApiApiKeys, value: string) {
        (this.authentications as any)[ExcelConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts Excel files to Dangl.AVA projects.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public excelConversionConvertToAva (excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/excel/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }

        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public excelConversionConvertToExcel (excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/excel/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }

        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Excel files to GAEB files.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public excelConversionConvertToGaeb (excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/excel/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }

        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts Excel files to Oenorm files.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public excelConversionConvertToOenorm (excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/excel/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }

        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GaebConversionApiApiKeys {
}

export class GaebConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GaebConversionApiApiKeys, value: string) {
        (this.authentications as any)[GaebConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts GAEB files to Dangl.AVA projects
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public gaebConversionConvertToAva (gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/gaeb/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts GAEB files to Excel
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public gaebConversionConvertToExcel (gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/gaeb/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public gaebConversionConvertToGaeb (gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/gaeb/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts GAEB files to Oenorm files
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public gaebConversionConvertToOenorm (gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/gaeb/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OenormConversionApiApiKeys {
}

export class OenormConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OenormConversionApiApiKeys, value: string) {
        (this.authentications as any)[OenormConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts ÖNorm files to Dangl.AVA projects
     * @param oenormFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public oenormConversionConvertToAva (oenormFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/oenorm/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts ÖNorm files to Excel
     * @param oenormFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public oenormConversionConvertToExcel (oenormFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/oenorm/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts ÖNorm files to GAEB files.
     * @param oenormFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public oenormConversionConvertToGaeb (oenormFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/oenorm/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts ÖNorm files to Oenorm files.
     * @param oenormFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public oenormConversionConvertToOenorm (oenormFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/oenorm/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RebConversionApiApiKeys {
}

export class RebConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RebConversionApiApiKeys, value: string) {
        (this.authentications as any)[RebConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts REB files to Dangl.AVA projects
     * @param rebFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public rebConversionConvertToAva (rebFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/reb/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts REB files to Excel
     * @param rebFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public rebConversionConvertToExcel (rebFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/reb/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts REB files to GAEB files
     * @param rebFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public rebConversionConvertToGaeb (rebFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/reb/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts REB files to Oenorm
     * @param rebFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public rebConversionConvertToOenorm (rebFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/reb/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SiaConversionApiApiKeys {
}

export class SiaConversionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SiaConversionApiApiKeys, value: string) {
        (this.authentications as any)[SiaConversionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Converts SIA 451 files to Dangl.AVA projects
     * @param siaFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    public siaConversionConvertToAva (siaFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProjectDto;  }> {
        const localVarPath = this.basePath + '/conversion/sia/ava';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }

        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProjectDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts SIA 451 files to Excel
     * @param siaFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    public siaConversionConvertToExcel (siaFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/sia/excel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }

        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }

        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts SIA 451 files to GAEB files
     * @param siaFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    public siaConversionConvertToGaeb (siaFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/sia/gaeb';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }

        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }

        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }

        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }

        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Converts SIA 451 files to Oenorm files
     * @param siaFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    public siaConversionConvertToOenorm (siaFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/conversion/sia/oenorm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }

        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }

        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }

        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StatusApiApiKeys {
}

export class StatusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StatusApiApiKeys, value: string) {
        (this.authentications as any)[StatusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary Reports the health status of the AVACloud API
     * @param {*} [options] Override http request options.
     */
    public statusGetStatus (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetStatus;  }> {
        const localVarPath = this.basePath + '/status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ValidationApiApiKeys {
}

export class ValidationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Dangl.Identity': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ValidationApiApiKeys, value: string) {
        (this.authentications as any)[ValidationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     * 
     * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
     * @param avaFile The file to validate
     * @param fileValidationSourceType You need to indicate which type of file is being provided, there is no auto detection mechanism
     * @param {*} [options] Override http request options.
     */
    public validationValidateFile (avaFile: FileParameter, fileValidationSourceType?: 'Gaeb' | 'Oenorm', options: any = {}) : Promise<{ response: http.IncomingMessage; body: ValidationResult;  }> {
        const localVarPath = this.basePath + '/validation/file';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (fileValidationSourceType !== undefined) {
            localVarQueryParameters['fileValidationSourceType'] = ObjectSerializer.serialize(fileValidationSourceType, "'Gaeb' | 'Oenorm'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (avaFile !== undefined) {
            localVarFormParams['avaFile'] = avaFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ValidationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ValidationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
     * @param avaProjectValidationSourceOptions The options used for the validation operation
     * @param {*} [options] Override http request options.
     */
    public validationValidateProject (avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ValidationResult;  }> {
        const localVarPath = this.basePath + '/validation/project';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'avaProjectValidationSourceOptions' is not null or undefined
        if (avaProjectValidationSourceOptions === null || avaProjectValidationSourceOptions === undefined) {
            throw new Error('Required parameter avaProjectValidationSourceOptions was null or undefined when calling validationValidateProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(avaProjectValidationSourceOptions, "PostAvaProjectValidationSourceOptions")
        };

        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ValidationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ValidationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}


export interface FileParameter {
  value: Buffer,
  options: {
    filename: string,
    contentType: string
  }
}

