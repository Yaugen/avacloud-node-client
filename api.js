"use strict";
/**
 * AVACloud API 1.34.1-beta0003
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.34.1-beta0003
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationApi = exports.ValidationApiApiKeys = exports.StatusApi = exports.StatusApiApiKeys = exports.SiaConversionApi = exports.SiaConversionApiApiKeys = exports.RebConversionApi = exports.RebConversionApiApiKeys = exports.OenormConversionApi = exports.OenormConversionApiApiKeys = exports.GaebConversionApi = exports.GaebConversionApiApiKeys = exports.ExcelConversionApi = exports.ExcelConversionApiApiKeys = exports.DanglIdentityApi = exports.DanglIdentityApiApiKeys = exports.AvaConversionApi = exports.AvaConversionApiApiKeys = exports.AslvConversionApi = exports.AslvConversionApiApiKeys = exports.VoidAuth = exports.OAuth = exports.ApiKeyAuth = exports.HttpBasicAuth = exports.XmlSchemaValidationCheckDetails = exports.WarrantyDurationDto = exports.ValidationType = exports.ValidationSeverity = exports.ValidationResult = exports.ValidationCheckType = exports.ValidationCheckResult = exports.TradeDiscountDto = exports.TokenResponseGet = exports.TokenRefreshPost = exports.TokenLoginPost = exports.SubDescriptionDto = exports.StandardizedDescriptionDto = exports.StandardReferenceTypeDto = exports.SpecialAwardKindDto = exports.ServiceTypeDto = exports.ServiceSpecificationGroupDto = exports.ServiceSpecificationDto = exports.STLBReferenceDto = exports.STLBKeyDto = exports.ResponseErrorType = exports.RegisterPost = exports.QuantityAssignmentDto = exports.ProjectValidationCheckDetails = exports.ProjectInformationDto = exports.ProjectDto = exports.ProductDataDto = exports.PriceTypeDto = exports.PriceRoundingModeDto = exports.PriceInformationDto = exports.PriceComponentTypeDto = exports.PriceComponentDto = exports.PostOenormDestinationOptions = exports.PostGaebDestinationOptions = exports.PostAvaSourceOptions = exports.PostAvaProjectValidationSourceOptions = exports.PositionTypeDto = exports.PositionDto = exports.PartyInformationDto = exports.OriginDto = exports.OenormPropertiesDto = exports.OenormPositionPropertiesDto = exports.OenormOriginCodeDto = exports.OenormNoteTextPropertiesDto = exports.ObjectValidationCheckDetails = exports.NoteTextDto = exports.LoginPost = exports.LabourPriceComponentDto = exports.ItemNumberTypeDto = exports.ItemNumberSchemaTierTypeDto = exports.ItemNumberSchemaTierDto = exports.ItemNumberSchemaDto = exports.ItemNumberDto = exports.HttpStatusCode = exports.GrossPriceComponentDto = exports.GetStatus = exports.ForgotPasswordPost = exports.FileValidationSourceType = exports.ExecutionDescriptionDto = exports.IElementDto = exports.ExchangePhaseDto = exports.DurationUnitDto = exports.DestinationRebType = exports.DestinationOenormType = exports.DestinationGaebType = exports.DestinationGaebExchangePhase = exports.ComplementedByQuantityDto = exports.CommercePropertiesDto = exports.ComissionStatusDto = exports.CatalogueTypeDto = exports.CatalogueReferenceDto = exports.CatalogueDto = exports.CalculationDto = exports.BankingInformationDto = exports.AwardTypeDto = exports.ArticleDataDto = exports.ApiError = exports.AdditionTypeDto = exports.AddendumStatusDto = void 0;
const localVarRequest = require("request");
let defaultBasePath = 'https://avacloud-api-dev.dangl-it.com';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        if (type === 'ProjectDto') {
            return data;
        }
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
/**
* This enumeration represents the status of an addendum, 'Nachtrag' in German
*/
class AddendumStatusDto {
    static getAttributeTypeMap() {
        return AddendumStatusDto.attributeTypeMap;
    }
}
exports.AddendumStatusDto = AddendumStatusDto;
AddendumStatusDto.discriminator = undefined;
AddendumStatusDto.attributeTypeMap = [];
/**
* Indicates the origin of an element.
*/
class AdditionTypeDto {
    static getAttributeTypeMap() {
        return AdditionTypeDto.attributeTypeMap;
    }
}
exports.AdditionTypeDto = AdditionTypeDto;
AdditionTypeDto.discriminator = undefined;
AdditionTypeDto.attributeTypeMap = [];
/**
* Data transfer class to convey api errors
*/
class ApiError {
    static getAttributeTypeMap() {
        return ApiError.attributeTypeMap;
    }
}
exports.ApiError = ApiError;
ApiError.discriminator = undefined;
ApiError.attributeTypeMap = [
    {
        "name": "errors",
        "baseName": "errors",
        "type": "{ [key: string]: Array<string>; }"
    }
];
/**
* This class represents a single article, usually used within ProductData
*/
class ArticleDataDto {
    static getAttributeTypeMap() {
        return ArticleDataDto.attributeTypeMap;
    }
}
exports.ArticleDataDto = ArticleDataDto;
ArticleDataDto.discriminator = undefined;
ArticleDataDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "articleNumber",
        "baseName": "articleNumber",
        "type": "string"
    },
    {
        "name": "quantity",
        "baseName": "quantity",
        "type": "number"
    },
    {
        "name": "unitTag",
        "baseName": "unitTag",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "shortText",
        "baseName": "shortText",
        "type": "string"
    },
    {
        "name": "longText",
        "baseName": "longText",
        "type": "string"
    },
    {
        "name": "htmlLongText",
        "baseName": "htmlLongText",
        "type": "string"
    }
];
/**
* This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard
*/
class AwardTypeDto {
    static getAttributeTypeMap() {
        return AwardTypeDto.attributeTypeMap;
    }
}
exports.AwardTypeDto = AwardTypeDto;
AwardTypeDto.discriminator = undefined;
AwardTypeDto.attributeTypeMap = [];
/**
* This is a class that represents the information about a bank connection. It is usually used within a PartyInformation.
*/
class BankingInformationDto {
    static getAttributeTypeMap() {
        return BankingInformationDto.attributeTypeMap;
    }
}
exports.BankingInformationDto = BankingInformationDto;
BankingInformationDto.discriminator = undefined;
BankingInformationDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "iban",
        "baseName": "iban",
        "type": "string"
    },
    {
        "name": "accountNumber",
        "baseName": "accountNumber",
        "type": "string"
    },
    {
        "name": "bic",
        "baseName": "bic",
        "type": "string"
    },
    {
        "name": "routingNumber",
        "baseName": "routingNumber",
        "type": "string"
    }
];
/**
* This class holds means to calculate mathematical expressions from given strings.
*/
class CalculationDto {
    static getAttributeTypeMap() {
        return CalculationDto.attributeTypeMap;
    }
}
exports.CalculationDto = CalculationDto;
CalculationDto.discriminator = undefined;
CalculationDto.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "formula",
        "baseName": "formula",
        "type": "string"
    },
    {
        "name": "result",
        "baseName": "result",
        "type": "number"
    },
    {
        "name": "valid",
        "baseName": "valid",
        "type": "boolean"
    },
    {
        "name": "errorPositionInLine",
        "baseName": "errorPositionInLine",
        "type": "number"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    },
    {
        "name": "catalogueReferences",
        "baseName": "catalogueReferences",
        "type": "Array<CatalogueReferenceDto>"
    }
];
/**
* This class describes an external catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
*/
class CatalogueDto {
    static getAttributeTypeMap() {
        return CatalogueDto.attributeTypeMap;
    }
}
exports.CatalogueDto = CatalogueDto;
CatalogueDto.discriminator = undefined;
CatalogueDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "gaebXmlId",
        "baseName": "gaebXmlId",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "catalogueType",
        "baseName": "catalogueType",
        "type": "CatalogueTypeDto"
    }
];
/**
* This class is used to link data between catalogues and objects.
*/
class CatalogueReferenceDto {
    static getAttributeTypeMap() {
        return CatalogueReferenceDto.attributeTypeMap;
    }
}
exports.CatalogueReferenceDto = CatalogueReferenceDto;
CatalogueReferenceDto.discriminator = undefined;
CatalogueReferenceDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "catalogueReferenceKey",
        "baseName": "catalogueReferenceKey",
        "type": "string"
    },
    {
        "name": "catalogueReferenceId",
        "baseName": "catalogueReferenceId",
        "type": "string"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    },
    {
        "name": "catalogue",
        "baseName": "catalogue",
        "type": "CatalogueDto"
    }
];
/**
* This enumeration describes the type of a catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
*/
class CatalogueTypeDto {
    static getAttributeTypeMap() {
        return CatalogueTypeDto.attributeTypeMap;
    }
}
exports.CatalogueTypeDto = CatalogueTypeDto;
CatalogueTypeDto.discriminator = undefined;
CatalogueTypeDto.attributeTypeMap = [];
/**
* Indicates if this service specification item is commissioned (and therefore should be executed), postponed for later or undefined.
*/
class ComissionStatusDto {
    static getAttributeTypeMap() {
        return ComissionStatusDto.attributeTypeMap;
    }
}
exports.ComissionStatusDto = ComissionStatusDto;
ComissionStatusDto.discriminator = undefined;
ComissionStatusDto.attributeTypeMap = [];
/**
* This class holds specialized information that is relevant to trade or commerce based data exchange scenarios, e.g. between customers, vendors, suppliers and distributors. It is used when exporting to GAEB XML 9x exchange phases.
*/
class CommercePropertiesDto {
    static getAttributeTypeMap() {
        return CommercePropertiesDto.attributeTypeMap;
    }
}
exports.CommercePropertiesDto = CommercePropertiesDto;
CommercePropertiesDto.discriminator = undefined;
CommercePropertiesDto.attributeTypeMap = [
    {
        "name": "articleNumber",
        "baseName": "articleNumber",
        "type": "string"
    },
    {
        "name": "eanGtinArticleNumber",
        "baseName": "eanGtinArticleNumber",
        "type": "string"
    },
    {
        "name": "ilnArticleNumber",
        "baseName": "ilnArticleNumber",
        "type": "string"
    },
    {
        "name": "catalogueNumber",
        "baseName": "catalogueNumber",
        "type": "string"
    },
    {
        "name": "catalogueArticleNumber",
        "baseName": "catalogueArticleNumber",
        "type": "string"
    }
];
/**
* This class represents the linking to a complementary position with a specific quantity set. For example, Position 'A' could be complementing Position 'B' with a total quantity of 20 units
*/
class ComplementedByQuantityDto {
    static getAttributeTypeMap() {
        return ComplementedByQuantityDto.attributeTypeMap;
    }
}
exports.ComplementedByQuantityDto = ComplementedByQuantityDto;
ComplementedByQuantityDto.discriminator = undefined;
ComplementedByQuantityDto.attributeTypeMap = [
    {
        "name": "quantity",
        "baseName": "quantity",
        "type": "number"
    },
    {
        "name": "complementingPositionId",
        "baseName": "complementingPositionId",
        "type": "string"
    }
];
/**
* The GAEB exchange phase to transform to
*/
class DestinationGaebExchangePhase {
    static getAttributeTypeMap() {
        return DestinationGaebExchangePhase.attributeTypeMap;
    }
}
exports.DestinationGaebExchangePhase = DestinationGaebExchangePhase;
DestinationGaebExchangePhase.discriminator = undefined;
DestinationGaebExchangePhase.attributeTypeMap = [];
/**
* Represents valid GAEB target types
*/
class DestinationGaebType {
    static getAttributeTypeMap() {
        return DestinationGaebType.attributeTypeMap;
    }
}
exports.DestinationGaebType = DestinationGaebType;
DestinationGaebType.discriminator = undefined;
DestinationGaebType.attributeTypeMap = [];
/**
* Represents valid Oenorm target types
*/
class DestinationOenormType {
    static getAttributeTypeMap() {
        return DestinationOenormType.attributeTypeMap;
    }
}
exports.DestinationOenormType = DestinationOenormType;
DestinationOenormType.discriminator = undefined;
DestinationOenormType.attributeTypeMap = [];
/**
* Represents valid REB target types
*/
class DestinationRebType {
    static getAttributeTypeMap() {
        return DestinationRebType.attributeTypeMap;
    }
}
exports.DestinationRebType = DestinationRebType;
DestinationRebType.discriminator = undefined;
DestinationRebType.attributeTypeMap = [];
/**
* This enumeration represents the unit of a duration
*/
class DurationUnitDto {
    static getAttributeTypeMap() {
        return DurationUnitDto.attributeTypeMap;
    }
}
exports.DurationUnitDto = DurationUnitDto;
DurationUnitDto.discriminator = undefined;
DurationUnitDto.attributeTypeMap = [];
/**
* Indicates a ServiceSpecification's exchange phase, based on the GAEB exchange phases.
*/
class ExchangePhaseDto {
    static getAttributeTypeMap() {
        return ExchangePhaseDto.attributeTypeMap;
    }
}
exports.ExchangePhaseDto = ExchangePhaseDto;
ExchangePhaseDto.discriminator = undefined;
ExchangePhaseDto.attributeTypeMap = [];
/**
* Base interface definition for elements within an ElementContainerBase.
*/
class IElementDto {
    static getAttributeTypeMap() {
        return IElementDto.attributeTypeMap;
    }
}
exports.IElementDto = IElementDto;
IElementDto.discriminator = "elementTypeDiscriminator";
IElementDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "gaebXmlId",
        "baseName": "gaebXmlId",
        "type": "string"
    },
    {
        "name": "addendumNumber",
        "baseName": "addendumNumber",
        "type": "string"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    },
    {
        "name": "catalogueReferences",
        "baseName": "catalogueReferences",
        "type": "Array<CatalogueReferenceDto>"
    },
    {
        "name": "elementTypeDiscriminator",
        "baseName": "elementTypeDiscriminator",
        "type": "string"
    }
];
class ExecutionDescriptionDto extends IElementDto {
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ExecutionDescriptionDto.attributeTypeMap);
    }
}
exports.ExecutionDescriptionDto = ExecutionDescriptionDto;
ExecutionDescriptionDto.discriminator = undefined;
ExecutionDescriptionDto.attributeTypeMap = [
    {
        "name": "blocks",
        "baseName": "blocks",
        "type": "Array<NoteTextDto>"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "elementType",
        "baseName": "elementType",
        "type": "string"
    }
];
/**
* This enum represents the source type for a file based validation operation
*/
class FileValidationSourceType {
    static getAttributeTypeMap() {
        return FileValidationSourceType.attributeTypeMap;
    }
}
exports.FileValidationSourceType = FileValidationSourceType;
FileValidationSourceType.discriminator = undefined;
FileValidationSourceType.attributeTypeMap = [];
class ForgotPasswordPost {
    static getAttributeTypeMap() {
        return ForgotPasswordPost.attributeTypeMap;
    }
}
exports.ForgotPasswordPost = ForgotPasswordPost;
ForgotPasswordPost.discriminator = undefined;
ForgotPasswordPost.attributeTypeMap = [
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "preferredLanguages",
        "baseName": "preferredLanguages",
        "type": "Array<string>"
    }
];
/**
* Indicates the status of the AVACloud service
*/
class GetStatus {
    static getAttributeTypeMap() {
        return GetStatus.attributeTypeMap;
    }
}
exports.GetStatus = GetStatus;
GetStatus.discriminator = undefined;
GetStatus.attributeTypeMap = [
    {
        "name": "isHealthy",
        "baseName": "isHealthy",
        "type": "boolean"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "environment",
        "baseName": "environment",
        "type": "string"
    }
];
/**
* This is used in an ElementContainerBase to hold the price composition.
*/
class GrossPriceComponentDto {
    static getAttributeTypeMap() {
        return GrossPriceComponentDto.attributeTypeMap;
    }
}
exports.GrossPriceComponentDto = GrossPriceComponentDto;
GrossPriceComponentDto.discriminator = undefined;
GrossPriceComponentDto.attributeTypeMap = [
    {
        "name": "taxRate",
        "baseName": "taxRate",
        "type": "number"
    },
    {
        "name": "deductionFactor",
        "baseName": "deductionFactor",
        "type": "number"
    },
    {
        "name": "totalNet",
        "baseName": "totalNet",
        "type": "number"
    },
    {
        "name": "totalDeducted",
        "baseName": "totalDeducted",
        "type": "number"
    },
    {
        "name": "totalTax",
        "baseName": "totalTax",
        "type": "number"
    },
    {
        "name": "totalGross",
        "baseName": "totalGross",
        "type": "number"
    },
    {
        "name": "totalGrossDeducted",
        "baseName": "totalGrossDeducted",
        "type": "number"
    },
    {
        "name": "totalTaxDeducted",
        "baseName": "totalTaxDeducted",
        "type": "number"
    }
];
/**
*
*/
class HttpStatusCode {
    static getAttributeTypeMap() {
        return HttpStatusCode.attributeTypeMap;
    }
}
exports.HttpStatusCode = HttpStatusCode;
HttpStatusCode.discriminator = undefined;
HttpStatusCode.attributeTypeMap = [];
/**
* This class represents as identifier of a certain service specification's element and is uniquely within the service specification.
*/
class ItemNumberDto {
    static getAttributeTypeMap() {
        return ItemNumberDto.attributeTypeMap;
    }
}
exports.ItemNumberDto = ItemNumberDto;
ItemNumberDto.discriminator = undefined;
ItemNumberDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "stringRepresentation",
        "baseName": "stringRepresentation",
        "type": "string"
    },
    {
        "name": "isSchemaCompliant",
        "baseName": "isSchemaCompliant",
        "type": "boolean"
    },
    {
        "name": "itemNumberSchema",
        "baseName": "itemNumberSchema",
        "type": "ItemNumberSchemaDto"
    },
    {
        "name": "identifiers",
        "baseName": "identifiers",
        "type": "Array<string>"
    },
    {
        "name": "isLot",
        "baseName": "isLot",
        "type": "boolean"
    },
    {
        "name": "hierarchyLevel",
        "baseName": "hierarchyLevel",
        "type": "number"
    },
    {
        "name": "isAttachedToPosition",
        "baseName": "isAttachedToPosition",
        "type": "boolean"
    }
];
/**
* The schema for ItemNumber's in a Project.
*/
class ItemNumberSchemaDto {
    static getAttributeTypeMap() {
        return ItemNumberSchemaDto.attributeTypeMap;
    }
}
exports.ItemNumberSchemaDto = ItemNumberSchemaDto;
ItemNumberSchemaDto.discriminator = undefined;
ItemNumberSchemaDto.attributeTypeMap = [
    {
        "name": "totalLength",
        "baseName": "totalLength",
        "type": "number"
    },
    {
        "name": "tiers",
        "baseName": "tiers",
        "type": "Array<ItemNumberSchemaTierDto>"
    },
    {
        "name": "separator",
        "baseName": "separator",
        "type": "string"
    },
    {
        "name": "filler",
        "baseName": "filler",
        "type": "string"
    },
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "skipNonExistingLevelsInPositionItemNumbers",
        "baseName": "skipNonExistingLevelsInPositionItemNumbers",
        "type": "boolean"
    },
    {
        "name": "skippedTiersFiller",
        "baseName": "skippedTiersFiller",
        "type": "string"
    },
    {
        "name": "schemaIsCorrectlyDefined",
        "baseName": "schemaIsCorrectlyDefined",
        "type": "boolean"
    }
];
/**
* Represents information about a single Tier in an ItemNumber.
*/
class ItemNumberSchemaTierDto {
    static getAttributeTypeMap() {
        return ItemNumberSchemaTierDto.attributeTypeMap;
    }
}
exports.ItemNumberSchemaTierDto = ItemNumberSchemaTierDto;
ItemNumberSchemaTierDto.discriminator = undefined;
ItemNumberSchemaTierDto.attributeTypeMap = [
    {
        "name": "length",
        "baseName": "length",
        "type": "number"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "ItemNumberTypeDto"
    },
    {
        "name": "tierType",
        "baseName": "tierType",
        "type": "ItemNumberSchemaTierTypeDto"
    },
    {
        "name": "isLot",
        "baseName": "isLot",
        "type": "boolean"
    },
    {
        "name": "increment",
        "baseName": "increment",
        "type": "number"
    },
    {
        "name": "tierName",
        "baseName": "tierName",
        "type": "string"
    }
];
/**
* Specifies the type an ItemNumberSchemaTier represents. For example, a tier may indicate to be used for positions or for groups.
*/
class ItemNumberSchemaTierTypeDto {
    static getAttributeTypeMap() {
        return ItemNumberSchemaTierTypeDto.attributeTypeMap;
    }
}
exports.ItemNumberSchemaTierTypeDto = ItemNumberSchemaTierTypeDto;
ItemNumberSchemaTierTypeDto.discriminator = undefined;
ItemNumberSchemaTierTypeDto.attributeTypeMap = [];
/**
* Determines the type of an ItemNumberSchema
*/
class ItemNumberTypeDto {
    static getAttributeTypeMap() {
        return ItemNumberTypeDto.attributeTypeMap;
    }
}
exports.ItemNumberTypeDto = ItemNumberTypeDto;
ItemNumberTypeDto.discriminator = undefined;
ItemNumberTypeDto.attributeTypeMap = [];
/**
* Based on the PriceComponent, this class is responsible for labour time components.
*/
class LabourPriceComponentDto {
    static getAttributeTypeMap() {
        return LabourPriceComponentDto.attributeTypeMap;
    }
}
exports.LabourPriceComponentDto = LabourPriceComponentDto;
LabourPriceComponentDto.discriminator = undefined;
LabourPriceComponentDto.attributeTypeMap = [
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "price",
        "baseName": "price",
        "type": "number"
    },
    {
        "name": "hourlyWage",
        "baseName": "hourlyWage",
        "type": "number"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<CalculationDto>"
    },
    {
        "name": "useOwnHourlyWage",
        "baseName": "useOwnHourlyWage",
        "type": "boolean"
    },
    {
        "name": "totalTime",
        "baseName": "totalTime",
        "type": "number"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    }
];
class LoginPost {
    static getAttributeTypeMap() {
        return LoginPost.attributeTypeMap;
    }
}
exports.LoginPost = LoginPost;
LoginPost.discriminator = undefined;
LoginPost.attributeTypeMap = [
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    },
    {
        "name": "staySignedIn",
        "baseName": "staySignedIn",
        "type": "boolean"
    }
];
class NoteTextDto extends IElementDto {
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NoteTextDto.attributeTypeMap);
    }
}
exports.NoteTextDto = NoteTextDto;
NoteTextDto.discriminator = undefined;
NoteTextDto.attributeTypeMap = [
    {
        "name": "isOpeningText",
        "baseName": "isOpeningText",
        "type": "boolean"
    },
    {
        "name": "isClosingText",
        "baseName": "isClosingText",
        "type": "boolean"
    },
    {
        "name": "shortText",
        "baseName": "shortText",
        "type": "string"
    },
    {
        "name": "additionType",
        "baseName": "additionType",
        "type": "AdditionTypeDto"
    },
    {
        "name": "longText",
        "baseName": "longText",
        "type": "string"
    },
    {
        "name": "htmlLongText",
        "baseName": "htmlLongText",
        "type": "string"
    },
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "standardizedDescription",
        "baseName": "standardizedDescription",
        "type": "StandardizedDescriptionDto"
    },
    {
        "name": "elementType",
        "baseName": "elementType",
        "type": "string"
    },
    {
        "name": "descriptionId",
        "baseName": "descriptionId",
        "type": "string"
    },
    {
        "name": "oenormNoteTextProperties",
        "baseName": "oenormNoteTextProperties",
        "type": "OenormNoteTextPropertiesDto"
    },
    {
        "name": "hasBidderCommentInHtmlLongText",
        "baseName": "hasBidderCommentInHtmlLongText",
        "type": "boolean"
    }
];
/**
* Basic information about Object check validation details, commonly used when checking GAEB 2000 files
*/
class ObjectValidationCheckDetails {
    static getAttributeTypeMap() {
        return ObjectValidationCheckDetails.attributeTypeMap;
    }
}
exports.ObjectValidationCheckDetails = ObjectValidationCheckDetails;
ObjectValidationCheckDetails.discriminator = undefined;
ObjectValidationCheckDetails.attributeTypeMap = [
    {
        "name": "elementPath",
        "baseName": "elementPath",
        "type": "string"
    }
];
/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for NoteTexts.
*/
class OenormNoteTextPropertiesDto {
    static getAttributeTypeMap() {
        return OenormNoteTextPropertiesDto.attributeTypeMap;
    }
}
exports.OenormNoteTextPropertiesDto = OenormNoteTextPropertiesDto;
OenormNoteTextPropertiesDto.discriminator = undefined;
OenormNoteTextPropertiesDto.attributeTypeMap = [
    {
        "name": "originCode",
        "baseName": "originCode",
        "type": "OenormOriginCodeDto"
    }
];
/**
* This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
*/
class OenormOriginCodeDto {
    static getAttributeTypeMap() {
        return OenormOriginCodeDto.attributeTypeMap;
    }
}
exports.OenormOriginCodeDto = OenormOriginCodeDto;
OenormOriginCodeDto.discriminator = undefined;
OenormOriginCodeDto.attributeTypeMap = [];
/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.
*/
class OenormPositionPropertiesDto {
    static getAttributeTypeMap() {
        return OenormPositionPropertiesDto.attributeTypeMap;
    }
}
exports.OenormPositionPropertiesDto = OenormPositionPropertiesDto;
OenormPositionPropertiesDto.discriminator = undefined;
OenormPositionPropertiesDto.attributeTypeMap = [
    {
        "name": "originCode",
        "baseName": "originCode",
        "type": "OenormOriginCodeDto"
    },
    {
        "name": "openingTextIsFreeText",
        "baseName": "openingTextIsFreeText",
        "type": "boolean"
    },
    {
        "name": "isMainPosition",
        "baseName": "isMainPosition",
        "type": "boolean"
    },
    {
        "name": "isUndividedPosition",
        "baseName": "isUndividedPosition",
        "type": "boolean"
    },
    {
        "name": "oenormShortText",
        "baseName": "oenormShortText",
        "type": "string"
    },
    {
        "name": "oenormShortTextAddition",
        "baseName": "oenormShortTextAddition",
        "type": "string"
    }
];
/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used.
*/
class OenormPropertiesDto {
    static getAttributeTypeMap() {
        return OenormPropertiesDto.attributeTypeMap;
    }
}
exports.OenormPropertiesDto = OenormPropertiesDto;
OenormPropertiesDto.discriminator = undefined;
OenormPropertiesDto.attributeTypeMap = [
    {
        "name": "originCode",
        "baseName": "originCode",
        "type": "OenormOriginCodeDto"
    },
    {
        "name": "openingTextIsFreeText",
        "baseName": "openingTextIsFreeText",
        "type": "boolean"
    }
];
/**
* Indicates where a service specification was originally created.
*/
class OriginDto {
    static getAttributeTypeMap() {
        return OriginDto.attributeTypeMap;
    }
}
exports.OriginDto = OriginDto;
OriginDto.discriminator = undefined;
OriginDto.attributeTypeMap = [];
/**
* Represents information about a party (a site or an organization).
*/
class PartyInformationDto {
    static getAttributeTypeMap() {
        return PartyInformationDto.attributeTypeMap;
    }
}
exports.PartyInformationDto = PartyInformationDto;
PartyInformationDto.discriminator = undefined;
PartyInformationDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "street",
        "baseName": "street",
        "type": "string"
    },
    {
        "name": "zipCode",
        "baseName": "zipCode",
        "type": "string"
    },
    {
        "name": "city",
        "baseName": "city",
        "type": "string"
    },
    {
        "name": "country",
        "baseName": "country",
        "type": "string"
    },
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "remarks",
        "baseName": "remarks",
        "type": "string"
    },
    {
        "name": "email",
        "baseName": "email",
        "type": "string"
    },
    {
        "name": "phone",
        "baseName": "phone",
        "type": "string"
    },
    {
        "name": "contactPersonName",
        "baseName": "contactPersonName",
        "type": "string"
    },
    {
        "name": "awardIdentifier",
        "baseName": "awardIdentifier",
        "type": "string"
    },
    {
        "name": "isInEuropeanEconomicArea",
        "baseName": "isInEuropeanEconomicArea",
        "type": "boolean"
    },
    {
        "name": "vatId",
        "baseName": "vatId",
        "type": "string"
    },
    {
        "name": "fax",
        "baseName": "fax",
        "type": "string"
    },
    {
        "name": "countryCode",
        "baseName": "countryCode",
        "type": "string"
    },
    {
        "name": "creditorOrDebtorIdentifier",
        "baseName": "creditorOrDebtorIdentifier",
        "type": "string"
    },
    {
        "name": "globalLocationNumber",
        "baseName": "globalLocationNumber",
        "type": "string"
    },
    {
        "name": "bankingInformation",
        "baseName": "bankingInformation",
        "type": "Array<BankingInformationDto>"
    }
];
class PositionDto extends IElementDto {
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PositionDto.attributeTypeMap);
    }
}
exports.PositionDto = PositionDto;
PositionDto.discriminator = undefined;
PositionDto.attributeTypeMap = [
    {
        "name": "unitPrice",
        "baseName": "unitPrice",
        "type": "number"
    },
    {
        "name": "unitPriceOverride",
        "baseName": "unitPriceOverride",
        "type": "number"
    },
    {
        "name": "quantity",
        "baseName": "quantity",
        "type": "number"
    },
    {
        "name": "quantityOverride",
        "baseName": "quantityOverride",
        "type": "number"
    },
    {
        "name": "isComplementingPosition",
        "baseName": "isComplementingPosition",
        "type": "boolean"
    },
    {
        "name": "complementsPositions",
        "baseName": "complementsPositions",
        "type": "Array<string>"
    },
    {
        "name": "complementingPricePercentageOverride",
        "baseName": "complementingPricePercentageOverride",
        "type": "number"
    },
    {
        "name": "complementingPricePercentage",
        "baseName": "complementingPricePercentage",
        "type": "number"
    },
    {
        "name": "unitTag",
        "baseName": "unitTag",
        "type": "string"
    },
    {
        "name": "labourComponents",
        "baseName": "labourComponents",
        "type": "LabourPriceComponentDto"
    },
    {
        "name": "priceComponents",
        "baseName": "priceComponents",
        "type": "Array<PriceComponentDto>"
    },
    {
        "name": "quantityComponents",
        "baseName": "quantityComponents",
        "type": "Array<CalculationDto>"
    },
    {
        "name": "subDescriptions",
        "baseName": "subDescriptions",
        "type": "Array<SubDescriptionDto>"
    },
    {
        "name": "comissionStatus",
        "baseName": "comissionStatus",
        "type": "ComissionStatusDto"
    },
    {
        "name": "complementedBy",
        "baseName": "complementedBy",
        "type": "Array<string>"
    },
    {
        "name": "complemented",
        "baseName": "complemented",
        "type": "boolean"
    },
    {
        "name": "amountToBeEnteredByBidder",
        "baseName": "amountToBeEnteredByBidder",
        "type": "boolean"
    },
    {
        "name": "priceCompositionRequired",
        "baseName": "priceCompositionRequired",
        "type": "boolean"
    },
    {
        "name": "useDifferentTaxRate",
        "baseName": "useDifferentTaxRate",
        "type": "boolean"
    },
    {
        "name": "taxRate",
        "baseName": "taxRate",
        "type": "number"
    },
    {
        "name": "itemNumber",
        "baseName": "itemNumber",
        "type": "ItemNumberDto"
    },
    {
        "name": "deductionFactor",
        "baseName": "deductionFactor",
        "type": "number"
    },
    {
        "name": "totalPrice",
        "baseName": "totalPrice",
        "type": "number"
    },
    {
        "name": "totalPriceGross",
        "baseName": "totalPriceGross",
        "type": "number"
    },
    {
        "name": "totalPriceGrossDeducted",
        "baseName": "totalPriceGrossDeducted",
        "type": "number"
    },
    {
        "name": "deductedPrice",
        "baseName": "deductedPrice",
        "type": "number"
    },
    {
        "name": "positionType",
        "baseName": "positionType",
        "type": "PositionTypeDto"
    },
    {
        "name": "priceType",
        "baseName": "priceType",
        "type": "PriceTypeDto"
    },
    {
        "name": "serviceType",
        "baseName": "serviceType",
        "type": "ServiceTypeDto"
    },
    {
        "name": "productData",
        "baseName": "productData",
        "type": "ProductDataDto"
    },
    {
        "name": "shortText",
        "baseName": "shortText",
        "type": "string"
    },
    {
        "name": "longText",
        "baseName": "longText",
        "type": "string"
    },
    {
        "name": "htmlLongText",
        "baseName": "htmlLongText",
        "type": "string"
    },
    {
        "name": "additionType",
        "baseName": "additionType",
        "type": "AdditionTypeDto"
    },
    {
        "name": "elementType",
        "baseName": "elementType",
        "type": "string"
    },
    {
        "name": "quantityAssignments",
        "baseName": "quantityAssignments",
        "type": "Array<QuantityAssignmentDto>"
    },
    {
        "name": "commerceProperties",
        "baseName": "commerceProperties",
        "type": "CommercePropertiesDto"
    },
    {
        "name": "alternativeTo",
        "baseName": "alternativeTo",
        "type": "string"
    },
    {
        "name": "alternativeIdentifier",
        "baseName": "alternativeIdentifier",
        "type": "number"
    },
    {
        "name": "alternativeGroupIdentifier",
        "baseName": "alternativeGroupIdentifier",
        "type": "number"
    },
    {
        "name": "isLumpSum",
        "baseName": "isLumpSum",
        "type": "boolean"
    },
    {
        "name": "repetitionTo",
        "baseName": "repetitionTo",
        "type": "string"
    },
    {
        "name": "standardizedDescription",
        "baseName": "standardizedDescription",
        "type": "StandardizedDescriptionDto"
    },
    {
        "name": "complementedByQuantities",
        "baseName": "complementedByQuantities",
        "type": "Array<ComplementedByQuantityDto>"
    },
    {
        "name": "executionDescriptionReference",
        "baseName": "executionDescriptionReference",
        "type": "string"
    },
    {
        "name": "notOffered",
        "baseName": "notOffered",
        "type": "boolean"
    },
    {
        "name": "oenormPositionProperties",
        "baseName": "oenormPositionProperties",
        "type": "OenormPositionPropertiesDto"
    },
    {
        "name": "descriptionId",
        "baseName": "descriptionId",
        "type": "string"
    },
    {
        "name": "hierarchyLevel",
        "baseName": "hierarchyLevel",
        "type": "number"
    },
    {
        "name": "addendumStatus",
        "baseName": "addendumStatus",
        "type": "AddendumStatusDto"
    },
    {
        "name": "hasBidderCommentInHtmlLongText",
        "baseName": "hasBidderCommentInHtmlLongText",
        "type": "boolean"
    }
];
/**
* This is a classification for Position elements.
*/
class PositionTypeDto {
    static getAttributeTypeMap() {
        return PositionTypeDto.attributeTypeMap;
    }
}
exports.PositionTypeDto = PositionTypeDto;
PositionTypeDto.discriminator = undefined;
PositionTypeDto.attributeTypeMap = [];
/**
* Options for validating an AVA project
*/
class PostAvaProjectValidationSourceOptions {
    static getAttributeTypeMap() {
        return PostAvaProjectValidationSourceOptions.attributeTypeMap;
    }
}
exports.PostAvaProjectValidationSourceOptions = PostAvaProjectValidationSourceOptions;
PostAvaProjectValidationSourceOptions.discriminator = undefined;
PostAvaProjectValidationSourceOptions.attributeTypeMap = [
    {
        "name": "avaProject",
        "baseName": "avaProject",
        "type": "ProjectDto"
    },
    {
        "name": "serviceSpecificationIndex",
        "baseName": "serviceSpecificationIndex",
        "type": "number"
    },
    {
        "name": "validationType",
        "baseName": "validationType",
        "type": "ValidationType"
    },
    {
        "name": "exchangePhase",
        "baseName": "exchangePhase",
        "type": "ExchangePhaseDto"
    },
    {
        "name": "avaSourceOptions",
        "baseName": "avaSourceOptions",
        "type": "PostAvaSourceOptions"
    },
    {
        "name": "oenormDestinationOptions",
        "baseName": "oenormDestinationOptions",
        "type": "PostOenormDestinationOptions"
    },
    {
        "name": "gaebDestinationOptions",
        "baseName": "gaebDestinationOptions",
        "type": "PostGaebDestinationOptions"
    }
];
/**
* Options for conversions from AVA
*/
class PostAvaSourceOptions {
    static getAttributeTypeMap() {
        return PostAvaSourceOptions.attributeTypeMap;
    }
}
exports.PostAvaSourceOptions = PostAvaSourceOptions;
PostAvaSourceOptions.discriminator = undefined;
PostAvaSourceOptions.attributeTypeMap = [
    {
        "name": "tryAutoGenerateItemNumbersAndSchema",
        "baseName": "tryAutoGenerateItemNumbersAndSchema",
        "type": "boolean"
    }
];
/**
* Options for conversions to GAEB
*/
class PostGaebDestinationOptions {
    static getAttributeTypeMap() {
        return PostGaebDestinationOptions.attributeTypeMap;
    }
}
exports.PostGaebDestinationOptions = PostGaebDestinationOptions;
PostGaebDestinationOptions.discriminator = undefined;
PostGaebDestinationOptions.attributeTypeMap = [
    {
        "name": "destinationGaebType",
        "baseName": "destinationGaebType",
        "type": "DestinationGaebType"
    },
    {
        "name": "targetExchangePhaseTransform",
        "baseName": "targetExchangePhaseTransform",
        "type": "DestinationGaebExchangePhase"
    },
    {
        "name": "enforceStrictOfferPhaseLongTextOutput",
        "baseName": "enforceStrictOfferPhaseLongTextOutput",
        "type": "boolean"
    },
    {
        "name": "exportQuantityDetermination",
        "baseName": "exportQuantityDetermination",
        "type": "boolean"
    },
    {
        "name": "removeUnprintableCharactersFromTexts",
        "baseName": "removeUnprintableCharactersFromTexts",
        "type": "boolean"
    },
    {
        "name": "forceIncludeDescriptions",
        "baseName": "forceIncludeDescriptions",
        "type": "boolean"
    },
    {
        "name": "treatNullItemNumberSchemaAsInvalid",
        "baseName": "treatNullItemNumberSchemaAsInvalid",
        "type": "boolean"
    }
];
/**
* Options for conversions to Oenorm
*/
class PostOenormDestinationOptions {
    static getAttributeTypeMap() {
        return PostOenormDestinationOptions.attributeTypeMap;
    }
}
exports.PostOenormDestinationOptions = PostOenormDestinationOptions;
PostOenormDestinationOptions.discriminator = undefined;
PostOenormDestinationOptions.attributeTypeMap = [
    {
        "name": "destinationOenormType",
        "baseName": "destinationOenormType",
        "type": "DestinationOenormType"
    },
    {
        "name": "tryRepairProjectStructure",
        "baseName": "tryRepairProjectStructure",
        "type": "boolean"
    },
    {
        "name": "skipTryEnforceSchemaCompliantXmlOutput",
        "baseName": "skipTryEnforceSchemaCompliantXmlOutput",
        "type": "boolean"
    },
    {
        "name": "removeUnprintableCharactersFromTexts",
        "baseName": "removeUnprintableCharactersFromTexts",
        "type": "boolean"
    }
];
/**
* This class provides means to store information about a price and it's composition. Note that this is referencing to a single price component, so for example a Position would have a list of PriceComponents, one for Material, one for Labour etc.
*/
class PriceComponentDto {
    static getAttributeTypeMap() {
        return PriceComponentDto.attributeTypeMap;
    }
}
exports.PriceComponentDto = PriceComponentDto;
PriceComponentDto.discriminator = undefined;
PriceComponentDto.attributeTypeMap = [
    {
        "name": "price",
        "baseName": "price",
        "type": "number"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<CalculationDto>"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    }
];
/**
* This enumeration models types of price components for better classification.
*/
class PriceComponentTypeDto {
    static getAttributeTypeMap() {
        return PriceComponentTypeDto.attributeTypeMap;
    }
}
exports.PriceComponentTypeDto = PriceComponentTypeDto;
PriceComponentTypeDto.discriminator = undefined;
PriceComponentTypeDto.attributeTypeMap = [];
/**
* Holds global price information for a ServiceSpecification
*/
class PriceInformationDto {
    static getAttributeTypeMap() {
        return PriceInformationDto.attributeTypeMap;
    }
}
exports.PriceInformationDto = PriceInformationDto;
PriceInformationDto.discriminator = undefined;
PriceInformationDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "hourlyWage",
        "baseName": "hourlyWage",
        "type": "number"
    },
    {
        "name": "deductionFactor",
        "baseName": "deductionFactor",
        "type": "number"
    },
    {
        "name": "flatSum",
        "baseName": "flatSum",
        "type": "number"
    },
    {
        "name": "taxRate",
        "baseName": "taxRate",
        "type": "number"
    },
    {
        "name": "tradeDiscounts",
        "baseName": "tradeDiscounts",
        "type": "Array<TradeDiscountDto>"
    }
];
/**
* This enum configures rounding modes for price calculations in projects
*/
class PriceRoundingModeDto {
    static getAttributeTypeMap() {
        return PriceRoundingModeDto.attributeTypeMap;
    }
}
exports.PriceRoundingModeDto = PriceRoundingModeDto;
PriceRoundingModeDto.discriminator = undefined;
PriceRoundingModeDto.attributeTypeMap = [];
/**
* This indicates the price type of a IPricedElement.
*/
class PriceTypeDto {
    static getAttributeTypeMap() {
        return PriceTypeDto.attributeTypeMap;
    }
}
exports.PriceTypeDto = PriceTypeDto;
PriceTypeDto.discriminator = undefined;
PriceTypeDto.attributeTypeMap = [];
/**
* This class represents data about products and their vendor
*/
class ProductDataDto {
    static getAttributeTypeMap() {
        return ProductDataDto.attributeTypeMap;
    }
}
exports.ProductDataDto = ProductDataDto;
ProductDataDto.discriminator = undefined;
ProductDataDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "vendor",
        "baseName": "vendor",
        "type": "PartyInformationDto"
    },
    {
        "name": "articles",
        "baseName": "articles",
        "type": "Array<ArticleDataDto>"
    },
    {
        "name": "shortText",
        "baseName": "shortText",
        "type": "string"
    },
    {
        "name": "longText",
        "baseName": "longText",
        "type": "string"
    },
    {
        "name": "htmlLongText",
        "baseName": "htmlLongText",
        "type": "string"
    }
];
/**
* A Project contains all relevant information for a construction project.
*/
class ProjectDto {
    static getAttributeTypeMap() {
        return ProjectDto.attributeTypeMap;
    }
}
exports.ProjectDto = ProjectDto;
ProjectDto.discriminator = undefined;
ProjectDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "priceAccuracy",
        "baseName": "priceAccuracy",
        "type": "number"
    },
    {
        "name": "forceStrictTotals",
        "baseName": "forceStrictTotals",
        "type": "boolean"
    },
    {
        "name": "priceRoundingMode",
        "baseName": "priceRoundingMode",
        "type": "PriceRoundingModeDto"
    },
    {
        "name": "projectInformation",
        "baseName": "projectInformation",
        "type": "ProjectInformationDto"
    },
    {
        "name": "serviceSpecifications",
        "baseName": "serviceSpecifications",
        "type": "Array<ServiceSpecificationDto>"
    },
    {
        "name": "gaebXmlId",
        "baseName": "gaebXmlId",
        "type": "string"
    }
];
/**
* General information about a Project.
*/
class ProjectInformationDto {
    static getAttributeTypeMap() {
        return ProjectInformationDto.attributeTypeMap;
    }
}
exports.ProjectInformationDto = ProjectInformationDto;
ProjectInformationDto.discriminator = undefined;
ProjectInformationDto.attributeTypeMap = [
    {
        "name": "buyer",
        "baseName": "buyer",
        "type": "PartyInformationDto"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "descriptionShort",
        "baseName": "descriptionShort",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "site",
        "baseName": "site",
        "type": "PartyInformationDto"
    },
    {
        "name": "itemNumberSchema",
        "baseName": "itemNumberSchema",
        "type": "ItemNumberSchemaDto"
    },
    {
        "name": "currencyShort",
        "baseName": "currencyShort",
        "type": "string"
    },
    {
        "name": "currencyLong",
        "baseName": "currencyLong",
        "type": "string"
    },
    {
        "name": "labourTimeLabel",
        "baseName": "labourTimeLabel",
        "type": "string"
    },
    {
        "name": "priceComponents",
        "baseName": "priceComponents",
        "type": "Array<string>"
    },
    {
        "name": "priceComponentTypes",
        "baseName": "priceComponentTypes",
        "type": "{ [key: string]: PriceComponentTypeDto; }"
    },
    {
        "name": "bidderCommentAllowed",
        "baseName": "bidderCommentAllowed",
        "type": "boolean"
    },
    {
        "name": "sideOffersAllowed",
        "baseName": "sideOffersAllowed",
        "type": "boolean"
    },
    {
        "name": "awardType",
        "baseName": "awardType",
        "type": "AwardTypeDto"
    },
    {
        "name": "specialAwardKind",
        "baseName": "specialAwardKind",
        "type": "SpecialAwardKindDto"
    }
];
/**
* Check details specificly for checking ProjectDto objects
*/
class ProjectValidationCheckDetails {
    static getAttributeTypeMap() {
        return ProjectValidationCheckDetails.attributeTypeMap;
    }
}
exports.ProjectValidationCheckDetails = ProjectValidationCheckDetails;
ProjectValidationCheckDetails.discriminator = undefined;
ProjectValidationCheckDetails.attributeTypeMap = [
    {
        "name": "elementId",
        "baseName": "elementId",
        "type": "string"
    }
];
/**
* Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of their parent Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
*/
class QuantityAssignmentDto {
    static getAttributeTypeMap() {
        return QuantityAssignmentDto.attributeTypeMap;
    }
}
exports.QuantityAssignmentDto = QuantityAssignmentDto;
QuantityAssignmentDto.discriminator = undefined;
QuantityAssignmentDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "quantity",
        "baseName": "quantity",
        "type": "number"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    },
    {
        "name": "catalogueReferences",
        "baseName": "catalogueReferences",
        "type": "Array<CatalogueReferenceDto>"
    }
];
class RegisterPost {
    static getAttributeTypeMap() {
        return RegisterPost.attributeTypeMap;
    }
}
exports.RegisterPost = RegisterPost;
RegisterPost.discriminator = undefined;
RegisterPost.attributeTypeMap = [
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "email",
        "baseName": "email",
        "type": "string"
    },
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    },
    {
        "name": "preferredLanguages",
        "baseName": "preferredLanguages",
        "type": "Array<string>"
    }
];
/**
*
*/
class ResponseErrorType {
    static getAttributeTypeMap() {
        return ResponseErrorType.attributeTypeMap;
    }
}
exports.ResponseErrorType = ResponseErrorType;
ResponseErrorType.discriminator = undefined;
ResponseErrorType.attributeTypeMap = [];
/**
* This class represents a single key reference within the German STLB \"Standardleistungsbuch Bau\"
*/
class STLBKeyDto {
    static getAttributeTypeMap() {
        return STLBKeyDto.attributeTypeMap;
    }
}
exports.STLBKeyDto = STLBKeyDto;
STLBKeyDto.discriminator = undefined;
STLBKeyDto.attributeTypeMap = [
    {
        "name": "artIdentifier",
        "baseName": "artIdentifier",
        "type": "number"
    },
    {
        "name": "artIndex",
        "baseName": "artIndex",
        "type": "number"
    },
    {
        "name": "kindIdentifier",
        "baseName": "kindIdentifier",
        "type": "number"
    }
];
/**
* This class represents a specialized reference to the German STLB \"Standardleistungsbuch Bau\". The STLB is a commercial offering and describes common services in the construction sector. When this is used, this describes the exact type of a service via a reference to this standard
*/
class STLBReferenceDto {
    static getAttributeTypeMap() {
        return STLBReferenceDto.attributeTypeMap;
    }
}
exports.STLBReferenceDto = STLBReferenceDto;
STLBReferenceDto.discriminator = undefined;
STLBReferenceDto.attributeTypeMap = [
    {
        "name": "versionDate",
        "baseName": "versionDate",
        "type": "Date"
    },
    {
        "name": "catalogueName",
        "baseName": "catalogueName",
        "type": "string"
    },
    {
        "name": "group",
        "baseName": "group",
        "type": "string"
    },
    {
        "name": "costGroup",
        "baseName": "costGroup",
        "type": "string"
    },
    {
        "name": "serviceArea",
        "baseName": "serviceArea",
        "type": "string"
    },
    {
        "name": "keys",
        "baseName": "keys",
        "type": "Array<STLBKeyDto>"
    }
];
/**
* This is the base class that holds information about a whole service specification.
*/
class ServiceSpecificationDto {
    static getAttributeTypeMap() {
        return ServiceSpecificationDto.attributeTypeMap;
    }
}
exports.ServiceSpecificationDto = ServiceSpecificationDto;
ServiceSpecificationDto.discriminator = undefined;
ServiceSpecificationDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "projectHourlyWage",
        "baseName": "projectHourlyWage",
        "type": "number"
    },
    {
        "name": "projectTaxRate",
        "baseName": "projectTaxRate",
        "type": "number"
    },
    {
        "name": "projectPriceComponents",
        "baseName": "projectPriceComponents",
        "type": "Array<string>"
    },
    {
        "name": "projectItemNumberSchema",
        "baseName": "projectItemNumberSchema",
        "type": "ItemNumberSchemaDto"
    },
    {
        "name": "elements",
        "baseName": "elements",
        "type": "Array<IElementDto>"
    },
    {
        "name": "projectLabourTimeLabel",
        "baseName": "projectLabourTimeLabel",
        "type": "string"
    },
    {
        "name": "containsDuplicateItemNumbers",
        "baseName": "containsDuplicateItemNumbers",
        "type": "boolean"
    },
    {
        "name": "containsDuplicateElementIds",
        "baseName": "containsDuplicateElementIds",
        "type": "boolean"
    },
    {
        "name": "ignoreDuplicateItemNumbers",
        "baseName": "ignoreDuplicateItemNumbers",
        "type": "boolean"
    },
    {
        "name": "ignoreDuplicateElementIds",
        "baseName": "ignoreDuplicateElementIds",
        "type": "boolean"
    },
    {
        "name": "totalPriceGrossByTaxRate",
        "baseName": "totalPriceGrossByTaxRate",
        "type": "Array<GrossPriceComponentDto>"
    },
    {
        "name": "ignoreChildPriceUpdates",
        "baseName": "ignoreChildPriceUpdates",
        "type": "boolean"
    },
    {
        "name": "deductedPrice",
        "baseName": "deductedPrice",
        "type": "number"
    },
    {
        "name": "deductionFactor",
        "baseName": "deductionFactor",
        "type": "number"
    },
    {
        "name": "absoluteDeduction",
        "baseName": "absoluteDeduction",
        "type": "number"
    },
    {
        "name": "totalPrice",
        "baseName": "totalPrice",
        "type": "number"
    },
    {
        "name": "totalPriceGross",
        "baseName": "totalPriceGross",
        "type": "number"
    },
    {
        "name": "totalPriceGrossDeducted",
        "baseName": "totalPriceGrossDeducted",
        "type": "number"
    },
    {
        "name": "priceType",
        "baseName": "priceType",
        "type": "PriceTypeDto"
    },
    {
        "name": "bidder",
        "baseName": "bidder",
        "type": "PartyInformationDto"
    },
    {
        "name": "bidderDiscriminator",
        "baseName": "bidderDiscriminator",
        "type": "string"
    },
    {
        "name": "gaebXmlId",
        "baseName": "gaebXmlId",
        "type": "string"
    },
    {
        "name": "projectInformation",
        "baseName": "projectInformation",
        "type": "ProjectInformationDto"
    },
    {
        "name": "exchangePhase",
        "baseName": "exchangePhase",
        "type": "ExchangePhaseDto"
    },
    {
        "name": "origin",
        "baseName": "origin",
        "type": "OriginDto"
    },
    {
        "name": "originDetail",
        "baseName": "originDetail",
        "type": "string"
    },
    {
        "name": "creationDate",
        "baseName": "creationDate",
        "type": "Date"
    },
    {
        "name": "offerByDate",
        "baseName": "offerByDate",
        "type": "Date"
    },
    {
        "name": "decisionDate",
        "baseName": "decisionDate",
        "type": "Date"
    },
    {
        "name": "submissionLocation",
        "baseName": "submissionLocation",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "priceInformation",
        "baseName": "priceInformation",
        "type": "PriceInformationDto"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    },
    {
        "name": "catalogueReferences",
        "baseName": "catalogueReferences",
        "type": "Array<CatalogueReferenceDto>"
    },
    {
        "name": "plannedExecutionStart",
        "baseName": "plannedExecutionStart",
        "type": "Date"
    },
    {
        "name": "plannedExecutionEnd",
        "baseName": "plannedExecutionEnd",
        "type": "Date"
    },
    {
        "name": "contractDate",
        "baseName": "contractDate",
        "type": "Date"
    },
    {
        "name": "contractIdentifier",
        "baseName": "contractIdentifier",
        "type": "string"
    },
    {
        "name": "warrantyDuration",
        "baseName": "warrantyDuration",
        "type": "WarrantyDurationDto"
    },
    {
        "name": "warrantyEnd",
        "baseName": "warrantyEnd",
        "type": "Date"
    },
    {
        "name": "approvalDate",
        "baseName": "approvalDate",
        "type": "Date"
    },
    {
        "name": "typeOfApproval",
        "baseName": "typeOfApproval",
        "type": "string"
    },
    {
        "name": "addendumNumber",
        "baseName": "addendumNumber",
        "type": "string"
    },
    {
        "name": "addendumStatus",
        "baseName": "addendumStatus",
        "type": "AddendumStatusDto"
    }
];
class ServiceSpecificationGroupDto extends IElementDto {
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ServiceSpecificationGroupDto.attributeTypeMap);
    }
}
exports.ServiceSpecificationGroupDto = ServiceSpecificationGroupDto;
ServiceSpecificationGroupDto.discriminator = undefined;
ServiceSpecificationGroupDto.attributeTypeMap = [
    {
        "name": "projectHourlyWage",
        "baseName": "projectHourlyWage",
        "type": "number"
    },
    {
        "name": "projectTaxRate",
        "baseName": "projectTaxRate",
        "type": "number"
    },
    {
        "name": "projectPriceComponents",
        "baseName": "projectPriceComponents",
        "type": "Array<string>"
    },
    {
        "name": "projectItemNumberSchema",
        "baseName": "projectItemNumberSchema",
        "type": "ItemNumberSchemaDto"
    },
    {
        "name": "elements",
        "baseName": "elements",
        "type": "Array<IElementDto>"
    },
    {
        "name": "projectLabourTimeLabel",
        "baseName": "projectLabourTimeLabel",
        "type": "string"
    },
    {
        "name": "containsDuplicateItemNumbers",
        "baseName": "containsDuplicateItemNumbers",
        "type": "boolean"
    },
    {
        "name": "containsDuplicateElementIds",
        "baseName": "containsDuplicateElementIds",
        "type": "boolean"
    },
    {
        "name": "ignoreDuplicateItemNumbers",
        "baseName": "ignoreDuplicateItemNumbers",
        "type": "boolean"
    },
    {
        "name": "ignoreDuplicateElementIds",
        "baseName": "ignoreDuplicateElementIds",
        "type": "boolean"
    },
    {
        "name": "totalPriceGrossByTaxRate",
        "baseName": "totalPriceGrossByTaxRate",
        "type": "Array<GrossPriceComponentDto>"
    },
    {
        "name": "ignoreChildPriceUpdates",
        "baseName": "ignoreChildPriceUpdates",
        "type": "boolean"
    },
    {
        "name": "deductedPrice",
        "baseName": "deductedPrice",
        "type": "number"
    },
    {
        "name": "deductionFactor",
        "baseName": "deductionFactor",
        "type": "number"
    },
    {
        "name": "absoluteDeduction",
        "baseName": "absoluteDeduction",
        "type": "number"
    },
    {
        "name": "totalPrice",
        "baseName": "totalPrice",
        "type": "number"
    },
    {
        "name": "totalPriceGross",
        "baseName": "totalPriceGross",
        "type": "number"
    },
    {
        "name": "totalPriceGrossDeducted",
        "baseName": "totalPriceGrossDeducted",
        "type": "number"
    },
    {
        "name": "priceType",
        "baseName": "priceType",
        "type": "PriceTypeDto"
    },
    {
        "name": "shortText",
        "baseName": "shortText",
        "type": "string"
    },
    {
        "name": "comissionStatus",
        "baseName": "comissionStatus",
        "type": "ComissionStatusDto"
    },
    {
        "name": "itemNumber",
        "baseName": "itemNumber",
        "type": "ItemNumberDto"
    },
    {
        "name": "elementType",
        "baseName": "elementType",
        "type": "string"
    },
    {
        "name": "isLot",
        "baseName": "isLot",
        "type": "boolean"
    },
    {
        "name": "alternativeTo",
        "baseName": "alternativeTo",
        "type": "string"
    },
    {
        "name": "oenormProperties",
        "baseName": "oenormProperties",
        "type": "OenormPropertiesDto"
    },
    {
        "name": "hierarchyLevel",
        "baseName": "hierarchyLevel",
        "type": "number"
    },
    {
        "name": "addendumStatus",
        "baseName": "addendumStatus",
        "type": "AddendumStatusDto"
    }
];
/**
* The service type describes the type of service a Position represents.
*/
class ServiceTypeDto {
    static getAttributeTypeMap() {
        return ServiceTypeDto.attributeTypeMap;
    }
}
exports.ServiceTypeDto = ServiceTypeDto;
ServiceTypeDto.discriminator = undefined;
ServiceTypeDto.attributeTypeMap = [];
/**
* This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary
*/
class SpecialAwardKindDto {
    static getAttributeTypeMap() {
        return SpecialAwardKindDto.attributeTypeMap;
    }
}
exports.SpecialAwardKindDto = SpecialAwardKindDto;
SpecialAwardKindDto.discriminator = undefined;
SpecialAwardKindDto.attributeTypeMap = [];
/**
* This enumeration identifies a pre-known standard used for referencing standardized descriptions.
*/
class StandardReferenceTypeDto {
    static getAttributeTypeMap() {
        return StandardReferenceTypeDto.attributeTypeMap;
    }
}
exports.StandardReferenceTypeDto = StandardReferenceTypeDto;
StandardReferenceTypeDto.discriminator = undefined;
StandardReferenceTypeDto.attributeTypeMap = [];
/**
* This class represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
*/
class StandardizedDescriptionDto {
    static getAttributeTypeMap() {
        return StandardizedDescriptionDto.attributeTypeMap;
    }
}
exports.StandardizedDescriptionDto = StandardizedDescriptionDto;
StandardizedDescriptionDto.discriminator = undefined;
StandardizedDescriptionDto.attributeTypeMap = [
    {
        "name": "standardReferenceType",
        "baseName": "standardReferenceType",
        "type": "StandardReferenceTypeDto"
    },
    {
        "name": "standardReference",
        "baseName": "standardReference",
        "type": "string"
    },
    {
        "name": "stlbReference",
        "baseName": "stlbReference",
        "type": "STLBReferenceDto"
    }
];
/**
* This is appended to a Position and is used to separate the complete Position into smaller amounts to be described separately, for example concrete walls could be attached to different building storeys.
*/
class SubDescriptionDto {
    static getAttributeTypeMap() {
        return SubDescriptionDto.attributeTypeMap;
    }
}
exports.SubDescriptionDto = SubDescriptionDto;
SubDescriptionDto.discriminator = undefined;
SubDescriptionDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "quantity",
        "baseName": "quantity",
        "type": "number"
    },
    {
        "name": "quantityOverride",
        "baseName": "quantityOverride",
        "type": "number"
    },
    {
        "name": "quantityComponents",
        "baseName": "quantityComponents",
        "type": "Array<CalculationDto>"
    },
    {
        "name": "amountToBeEnteredByBidder",
        "baseName": "amountToBeEnteredByBidder",
        "type": "boolean"
    },
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "shortText",
        "baseName": "shortText",
        "type": "string"
    },
    {
        "name": "longText",
        "baseName": "longText",
        "type": "string"
    },
    {
        "name": "unitTag",
        "baseName": "unitTag",
        "type": "string"
    },
    {
        "name": "htmlLongText",
        "baseName": "htmlLongText",
        "type": "string"
    },
    {
        "name": "additionType",
        "baseName": "additionType",
        "type": "AdditionTypeDto"
    },
    {
        "name": "standardizedDescription",
        "baseName": "standardizedDescription",
        "type": "StandardizedDescriptionDto"
    },
    {
        "name": "executionDescriptionReference",
        "baseName": "executionDescriptionReference",
        "type": "string"
    },
    {
        "name": "projectCatalogues",
        "baseName": "projectCatalogues",
        "type": "Array<CatalogueDto>"
    },
    {
        "name": "descriptionId",
        "baseName": "descriptionId",
        "type": "string"
    },
    {
        "name": "hasBidderCommentInHtmlLongText",
        "baseName": "hasBidderCommentInHtmlLongText",
        "type": "boolean"
    },
    {
        "name": "elementType",
        "baseName": "elementType",
        "type": "string"
    },
    {
        "name": "elementTypeDiscriminator",
        "baseName": "elementTypeDiscriminator",
        "type": "string"
    }
];
class TokenLoginPost {
    static getAttributeTypeMap() {
        return TokenLoginPost.attributeTypeMap;
    }
}
exports.TokenLoginPost = TokenLoginPost;
TokenLoginPost.discriminator = undefined;
TokenLoginPost.attributeTypeMap = [
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    },
    {
        "name": "password",
        "baseName": "password",
        "type": "string"
    }
];
class TokenRefreshPost {
    static getAttributeTypeMap() {
        return TokenRefreshPost.attributeTypeMap;
    }
}
exports.TokenRefreshPost = TokenRefreshPost;
TokenRefreshPost.discriminator = undefined;
TokenRefreshPost.attributeTypeMap = [
    {
        "name": "refreshToken",
        "baseName": "refreshToken",
        "type": "string"
    }
];
class TokenResponseGet {
    static getAttributeTypeMap() {
        return TokenResponseGet.attributeTypeMap;
    }
}
exports.TokenResponseGet = TokenResponseGet;
TokenResponseGet.discriminator = undefined;
TokenResponseGet.attributeTypeMap = [
    {
        "name": "accessToken",
        "baseName": "accessToken",
        "type": "string"
    },
    {
        "name": "error",
        "baseName": "error",
        "type": "string"
    },
    {
        "name": "errorDescription",
        "baseName": "errorDescription",
        "type": "string"
    },
    {
        "name": "expiresIn",
        "baseName": "expiresIn",
        "type": "number"
    },
    {
        "name": "httpErrorReason",
        "baseName": "httpErrorReason",
        "type": "string"
    },
    {
        "name": "httpStatusCode",
        "baseName": "httpStatusCode",
        "type": "HttpStatusCode"
    },
    {
        "name": "identityToken",
        "baseName": "identityToken",
        "type": "string"
    },
    {
        "name": "isError",
        "baseName": "isError",
        "type": "boolean"
    },
    {
        "name": "refreshToken",
        "baseName": "refreshToken",
        "type": "string"
    },
    {
        "name": "tokenType",
        "baseName": "tokenType",
        "type": "string"
    },
    {
        "name": "errorType",
        "baseName": "errorType",
        "type": "ResponseErrorType"
    }
];
/**
* This class holds information about offered trade discounts (Skonto in German)
*/
class TradeDiscountDto {
    static getAttributeTypeMap() {
        return TradeDiscountDto.attributeTypeMap;
    }
}
exports.TradeDiscountDto = TradeDiscountDto;
TradeDiscountDto.discriminator = undefined;
TradeDiscountDto.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "deadline",
        "baseName": "deadline",
        "type": "number"
    },
    {
        "name": "rate",
        "baseName": "rate",
        "type": "number"
    }
];
/**
* This class models the results of a single check performed during a validation action
*/
class ValidationCheckResult {
    static getAttributeTypeMap() {
        return ValidationCheckResult.attributeTypeMap;
    }
}
exports.ValidationCheckResult = ValidationCheckResult;
ValidationCheckResult.discriminator = undefined;
ValidationCheckResult.attributeTypeMap = [
    {
        "name": "severity",
        "baseName": "severity",
        "type": "ValidationSeverity"
    },
    {
        "name": "checkType",
        "baseName": "checkType",
        "type": "ValidationCheckType"
    },
    {
        "name": "message",
        "baseName": "message",
        "type": "string"
    },
    {
        "name": "objectValidationCheckDetails",
        "baseName": "objectValidationCheckDetails",
        "type": "ObjectValidationCheckDetails"
    },
    {
        "name": "xmlSchemaValidationCheckDetails",
        "baseName": "xmlSchemaValidationCheckDetails",
        "type": "XmlSchemaValidationCheckDetails"
    },
    {
        "name": "projectValidationCheckDetails",
        "baseName": "projectValidationCheckDetails",
        "type": "ProjectValidationCheckDetails"
    }
];
/**
* Enumeration for the different types of checks performed
*/
class ValidationCheckType {
    static getAttributeTypeMap() {
        return ValidationCheckType.attributeTypeMap;
    }
}
exports.ValidationCheckType = ValidationCheckType;
ValidationCheckType.discriminator = undefined;
ValidationCheckType.attributeTypeMap = [];
/**
* This class represents the result of a validation operation
*/
class ValidationResult {
    static getAttributeTypeMap() {
        return ValidationResult.attributeTypeMap;
    }
}
exports.ValidationResult = ValidationResult;
ValidationResult.discriminator = undefined;
ValidationResult.attributeTypeMap = [
    {
        "name": "isSchemaCompliant",
        "baseName": "isSchemaCompliant",
        "type": "boolean"
    },
    {
        "name": "checkResults",
        "baseName": "checkResults",
        "type": "Array<ValidationCheckResult>"
    },
    {
        "name": "validationType",
        "baseName": "validationType",
        "type": "ValidationType"
    },
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    }
];
/**
* Indicates the severity of a check
*/
class ValidationSeverity {
    static getAttributeTypeMap() {
        return ValidationSeverity.attributeTypeMap;
    }
}
exports.ValidationSeverity = ValidationSeverity;
ValidationSeverity.discriminator = undefined;
ValidationSeverity.attributeTypeMap = [];
/**
* This enumeration represents the possible conversion targets when performing a validation
*/
class ValidationType {
    static getAttributeTypeMap() {
        return ValidationType.attributeTypeMap;
    }
}
exports.ValidationType = ValidationType;
ValidationType.discriminator = undefined;
ValidationType.attributeTypeMap = [];
/**
* This class does not represent a typical `TimeSpan` but has a scalar value int Duration and a DurationUnit Unit to represent durations as typically used in contracts, e.g. 5 Months
*/
class WarrantyDurationDto {
    static getAttributeTypeMap() {
        return WarrantyDurationDto.attributeTypeMap;
    }
}
exports.WarrantyDurationDto = WarrantyDurationDto;
WarrantyDurationDto.discriminator = undefined;
WarrantyDurationDto.attributeTypeMap = [
    {
        "name": "duration",
        "baseName": "duration",
        "type": "number"
    },
    {
        "name": "unit",
        "baseName": "unit",
        "type": "DurationUnitDto"
    }
];
/**
* Check details for an XML schema validation result
*/
class XmlSchemaValidationCheckDetails {
    static getAttributeTypeMap() {
        return XmlSchemaValidationCheckDetails.attributeTypeMap;
    }
}
exports.XmlSchemaValidationCheckDetails = XmlSchemaValidationCheckDetails;
XmlSchemaValidationCheckDetails.discriminator = undefined;
XmlSchemaValidationCheckDetails.attributeTypeMap = [
    {
        "name": "lineNumber",
        "baseName": "lineNumber",
        "type": "number"
    },
    {
        "name": "linePosition",
        "baseName": "linePosition",
        "type": "number"
    }
];
let enumsMap = {};
let typeMap = {
    "AddendumStatusDto": AddendumStatusDto,
    "AdditionTypeDto": AdditionTypeDto,
    "ApiError": ApiError,
    "ArticleDataDto": ArticleDataDto,
    "AwardTypeDto": AwardTypeDto,
    "BankingInformationDto": BankingInformationDto,
    "CalculationDto": CalculationDto,
    "CatalogueDto": CatalogueDto,
    "CatalogueReferenceDto": CatalogueReferenceDto,
    "CatalogueTypeDto": CatalogueTypeDto,
    "ComissionStatusDto": ComissionStatusDto,
    "CommercePropertiesDto": CommercePropertiesDto,
    "ComplementedByQuantityDto": ComplementedByQuantityDto,
    "DestinationGaebExchangePhase": DestinationGaebExchangePhase,
    "DestinationGaebType": DestinationGaebType,
    "DestinationOenormType": DestinationOenormType,
    "DestinationRebType": DestinationRebType,
    "DurationUnitDto": DurationUnitDto,
    "ExchangePhaseDto": ExchangePhaseDto,
    "ExecutionDescriptionDto": ExecutionDescriptionDto,
    "FileValidationSourceType": FileValidationSourceType,
    "ForgotPasswordPost": ForgotPasswordPost,
    "GetStatus": GetStatus,
    "GrossPriceComponentDto": GrossPriceComponentDto,
    "HttpStatusCode": HttpStatusCode,
    "IElementDto": IElementDto,
    "ItemNumberDto": ItemNumberDto,
    "ItemNumberSchemaDto": ItemNumberSchemaDto,
    "ItemNumberSchemaTierDto": ItemNumberSchemaTierDto,
    "ItemNumberSchemaTierTypeDto": ItemNumberSchemaTierTypeDto,
    "ItemNumberTypeDto": ItemNumberTypeDto,
    "LabourPriceComponentDto": LabourPriceComponentDto,
    "LoginPost": LoginPost,
    "NoteTextDto": NoteTextDto,
    "ObjectValidationCheckDetails": ObjectValidationCheckDetails,
    "OenormNoteTextPropertiesDto": OenormNoteTextPropertiesDto,
    "OenormOriginCodeDto": OenormOriginCodeDto,
    "OenormPositionPropertiesDto": OenormPositionPropertiesDto,
    "OenormPropertiesDto": OenormPropertiesDto,
    "OriginDto": OriginDto,
    "PartyInformationDto": PartyInformationDto,
    "PositionDto": PositionDto,
    "PositionTypeDto": PositionTypeDto,
    "PostAvaProjectValidationSourceOptions": PostAvaProjectValidationSourceOptions,
    "PostAvaSourceOptions": PostAvaSourceOptions,
    "PostGaebDestinationOptions": PostGaebDestinationOptions,
    "PostOenormDestinationOptions": PostOenormDestinationOptions,
    "PriceComponentDto": PriceComponentDto,
    "PriceComponentTypeDto": PriceComponentTypeDto,
    "PriceInformationDto": PriceInformationDto,
    "PriceRoundingModeDto": PriceRoundingModeDto,
    "PriceTypeDto": PriceTypeDto,
    "ProductDataDto": ProductDataDto,
    "ProjectDto": ProjectDto,
    "ProjectInformationDto": ProjectInformationDto,
    "ProjectValidationCheckDetails": ProjectValidationCheckDetails,
    "QuantityAssignmentDto": QuantityAssignmentDto,
    "RegisterPost": RegisterPost,
    "ResponseErrorType": ResponseErrorType,
    "STLBKeyDto": STLBKeyDto,
    "STLBReferenceDto": STLBReferenceDto,
    "ServiceSpecificationDto": ServiceSpecificationDto,
    "ServiceSpecificationGroupDto": ServiceSpecificationGroupDto,
    "ServiceTypeDto": ServiceTypeDto,
    "SpecialAwardKindDto": SpecialAwardKindDto,
    "StandardReferenceTypeDto": StandardReferenceTypeDto,
    "StandardizedDescriptionDto": StandardizedDescriptionDto,
    "SubDescriptionDto": SubDescriptionDto,
    "TokenLoginPost": TokenLoginPost,
    "TokenRefreshPost": TokenRefreshPost,
    "TokenResponseGet": TokenResponseGet,
    "TradeDiscountDto": TradeDiscountDto,
    "ValidationCheckResult": ValidationCheckResult,
    "ValidationCheckType": ValidationCheckType,
    "ValidationResult": ValidationResult,
    "ValidationSeverity": ValidationSeverity,
    "ValidationType": ValidationType,
    "WarrantyDurationDto": WarrantyDurationDto,
    "XmlSchemaValidationCheckDetails": XmlSchemaValidationCheckDetails,
};
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var AslvConversionApiApiKeys;
(function (AslvConversionApiApiKeys) {
})(AslvConversionApiApiKeys = exports.AslvConversionApiApiKeys || (exports.AslvConversionApiApiKeys = {}));
class AslvConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AslvConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts Aslv files to Dangl.AVA projects
     * @param aslvFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToAva(aslvFile, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/aslv/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Aslv files to Excel
     * @param aslvFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToExcel(aslvFile, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/aslv/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Aslv files to GAEB files
     * @param aslvFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToGaeb(aslvFile, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/aslv/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Aslv files to Oenorm files
     * @param aslvFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToOenorm(aslvFile, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/aslv/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (aslvFile !== undefined) {
            localVarFormParams['aslvFile'] = aslvFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AslvConversionApi = AslvConversionApi;
var AvaConversionApiApiKeys;
(function (AvaConversionApiApiKeys) {
})(AvaConversionApiApiKeys = exports.AvaConversionApiApiKeys || (exports.AvaConversionApiApiKeys = {}));
class AvaConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AvaConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToAva(avaProject, tryAutoGenerateItemNumbersAndSchema, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/ava/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToAva.');
        }
        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: avaProject
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Dangl.AVA projects to Excel
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToExcel(avaProject, tryAutoGenerateItemNumbersAndSchema, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/ava/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToExcel.');
        }
        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Dangl.AVA projects to GAEB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToGaeb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/ava/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToGaeb.');
        }
        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Dangl.AVA projects to Oenorm
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToOenorm(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/ava/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToOenorm.');
        }
        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Dangl.AVA projects to REB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationRebType Defaults to D11
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToReb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationRebType, options = {}) {
        const localVarPath = this.basePath + '/conversion/ava/reb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToReb.');
        }
        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }
        if (destinationRebType !== undefined) {
            localVarQueryParameters['DestinationRebType'] = ObjectSerializer.serialize(destinationRebType, "'D11' | 'X31GaebXmlV32'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Dangl.AVA projects to SIA 451
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToSia(avaProject, tryAutoGenerateItemNumbersAndSchema, options = {}) {
        const localVarPath = this.basePath + '/conversion/ava/sia';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProject' is not null or undefined
        if (avaProject === null || avaProject === undefined) {
            throw new Error('Required parameter avaProject was null or undefined when calling avaConversionConvertToSia.');
        }
        if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
            localVarQueryParameters['TryAutoGenerateItemNumbersAndSchema'] = ObjectSerializer.serialize(tryAutoGenerateItemNumbersAndSchema, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: avaProject,
            json: true
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AvaConversionApi = AvaConversionApi;
var DanglIdentityApiApiKeys;
(function (DanglIdentityApiApiKeys) {
})(DanglIdentityApiApiKeys = exports.DanglIdentityApiApiKeys || (exports.DanglIdentityApiApiKeys = {}));
class DanglIdentityApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DanglIdentityApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @param model
     * @param {*} [options] Override http request options.
     */
    danglIdentityLoginAndReturnToken(model, options = {}) {
        const localVarPath = this.basePath + '/identity/token-login';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling danglIdentityLoginAndReturnToken.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "TokenLoginPost")
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TokenResponseGet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param model
     * @param redirectUrl
     * @param {*} [options] Override http request options.
     */
    danglIdentityLoginWithCookie(model, redirectUrl, options = {}) {
        const localVarPath = this.basePath + '/identity/login';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling danglIdentityLoginWithCookie.');
        }
        if (redirectUrl !== undefined) {
            localVarQueryParameters['redirectUrl'] = ObjectSerializer.serialize(redirectUrl, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "LoginPost")
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param model
     * @param {*} [options] Override http request options.
     */
    danglIdentityRefreshToken(model, options = {}) {
        const localVarPath = this.basePath + '/identity/token-refresh';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling danglIdentityRefreshToken.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "TokenRefreshPost")
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "TokenResponseGet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param registerModel
     * @param {*} [options] Override http request options.
     */
    danglIdentityRegister(registerModel, options = {}) {
        const localVarPath = this.basePath + '/identity/register';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'registerModel' is not null or undefined
        if (registerModel === null || registerModel === undefined) {
            throw new Error('Required parameter registerModel was null or undefined when calling danglIdentityRegister.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registerModel, "RegisterPost")
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param forgotPasswordModel
     * @param {*} [options] Override http request options.
     */
    danglIdentityRequestPasswordReset(forgotPasswordModel, options = {}) {
        const localVarPath = this.basePath + '/identity/password-forgotten';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'forgotPasswordModel' is not null or undefined
        if (forgotPasswordModel === null || forgotPasswordModel === undefined) {
            throw new Error('Required parameter forgotPasswordModel was null or undefined when calling danglIdentityRequestPasswordReset.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(forgotPasswordModel, "ForgotPasswordPost")
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param {*} [options] Override http request options.
     */
    danglIdentitySignOutWithSignInManager(options = {}) {
        const localVarPath = this.basePath + '/identity/login';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DanglIdentityApi = DanglIdentityApi;
var ExcelConversionApiApiKeys;
(function (ExcelConversionApiApiKeys) {
})(ExcelConversionApiApiKeys = exports.ExcelConversionApiApiKeys || (exports.ExcelConversionApiApiKeys = {}));
class ExcelConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ExcelConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts Excel files to Dangl.AVA projects.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToAva(excelFile, readNewElements, rebuildItemNumberSchema, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/excel/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }
        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToExcel(excelFile, readNewElements, rebuildItemNumberSchema, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/excel/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }
        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Excel files to GAEB files.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToGaeb(excelFile, readNewElements, rebuildItemNumberSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/excel/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }
        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts Excel files to Oenorm files.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToOenorm(excelFile, readNewElements, rebuildItemNumberSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/excel/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (readNewElements !== undefined) {
            localVarQueryParameters['ReadNewElements'] = ObjectSerializer.serialize(readNewElements, "boolean");
        }
        if (rebuildItemNumberSchema !== undefined) {
            localVarQueryParameters['RebuildItemNumberSchema'] = ObjectSerializer.serialize(rebuildItemNumberSchema, "boolean");
        }
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (excelFile !== undefined) {
            localVarFormParams['excelFile'] = excelFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ExcelConversionApi = ExcelConversionApi;
var GaebConversionApiApiKeys;
(function (GaebConversionApiApiKeys) {
})(GaebConversionApiApiKeys = exports.GaebConversionApiApiKeys || (exports.GaebConversionApiApiKeys = {}));
class GaebConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[GaebConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts GAEB files to Dangl.AVA projects
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToAva(gaebFile, supportSkippedItemNumberLevelsInPositions, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/gaeb/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts GAEB files to Excel
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToExcel(gaebFile, supportSkippedItemNumberLevelsInPositions, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/gaeb/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToGaeb(gaebFile, supportSkippedItemNumberLevelsInPositions, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/gaeb/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts GAEB files to Oenorm files
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToOenorm(gaebFile, supportSkippedItemNumberLevelsInPositions, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/gaeb/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (supportSkippedItemNumberLevelsInPositions !== undefined) {
            localVarQueryParameters['SupportSkippedItemNumberLevelsInPositions'] = ObjectSerializer.serialize(supportSkippedItemNumberLevelsInPositions, "boolean");
        }
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (gaebFile !== undefined) {
            localVarFormParams['gaebFile'] = gaebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.GaebConversionApi = GaebConversionApi;
var OenormConversionApiApiKeys;
(function (OenormConversionApiApiKeys) {
})(OenormConversionApiApiKeys = exports.OenormConversionApiApiKeys || (exports.OenormConversionApiApiKeys = {}));
class OenormConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[OenormConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts ÖNorm files to Dangl.AVA projects
     * @param oenormFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToAva(oenormFile, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/oenorm/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts ÖNorm files to Excel
     * @param oenormFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToExcel(oenormFile, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/oenorm/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts ÖNorm files to GAEB files.
     * @param oenormFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToGaeb(oenormFile, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/oenorm/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts ÖNorm files to Oenorm files.
     * @param oenormFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToOenorm(oenormFile, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/oenorm/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (oenormFile !== undefined) {
            localVarFormParams['oenormFile'] = oenormFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.OenormConversionApi = OenormConversionApi;
var RebConversionApiApiKeys;
(function (RebConversionApiApiKeys) {
})(RebConversionApiApiKeys = exports.RebConversionApiApiKeys || (exports.RebConversionApiApiKeys = {}));
class RebConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RebConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts REB files to Dangl.AVA projects
     * @param rebFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToAva(rebFile, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/reb/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts REB files to Excel
     * @param rebFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToExcel(rebFile, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/reb/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts REB files to GAEB files
     * @param rebFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToGaeb(rebFile, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/reb/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts REB files to Oenorm
     * @param rebFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToOenorm(rebFile, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/reb/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (rebFile !== undefined) {
            localVarFormParams['rebFile'] = rebFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.RebConversionApi = RebConversionApi;
var SiaConversionApiApiKeys;
(function (SiaConversionApiApiKeys) {
})(SiaConversionApiApiKeys = exports.SiaConversionApiApiKeys || (exports.SiaConversionApiApiKeys = {}));
class SiaConversionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SiaConversionApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Converts SIA 451 files to Dangl.AVA projects
     * @param siaFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToAva(siaFile, removePlainTextLongTexts, removeHtmlLongTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/sia/ava';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (removePlainTextLongTexts !== undefined) {
            localVarQueryParameters['RemovePlainTextLongTexts'] = ObjectSerializer.serialize(removePlainTextLongTexts, "boolean");
        }
        if (removeHtmlLongTexts !== undefined) {
            localVarQueryParameters['RemoveHtmlLongTexts'] = ObjectSerializer.serialize(removeHtmlLongTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts SIA 451 files to Excel
     * @param siaFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToExcel(siaFile, writePrices, writeLongTexts, conversionCulture, options = {}) {
        const localVarPath = this.basePath + '/conversion/sia/excel';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (writePrices !== undefined) {
            localVarQueryParameters['WritePrices'] = ObjectSerializer.serialize(writePrices, "boolean");
        }
        if (writeLongTexts !== undefined) {
            localVarQueryParameters['WriteLongTexts'] = ObjectSerializer.serialize(writeLongTexts, "boolean");
        }
        if (conversionCulture !== undefined) {
            localVarQueryParameters['ConversionCulture'] = ObjectSerializer.serialize(conversionCulture, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts SIA 451 files to GAEB files
     * @param siaFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToGaeb(siaFile, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options = {}) {
        const localVarPath = this.basePath + '/conversion/sia/gaeb';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationGaebType !== undefined) {
            localVarQueryParameters['DestinationGaebType'] = ObjectSerializer.serialize(destinationGaebType, "'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce'");
        }
        if (targetExchangePhaseTransform !== undefined) {
            localVarQueryParameters['TargetExchangePhaseTransform'] = ObjectSerializer.serialize(targetExchangePhaseTransform, "'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'");
        }
        if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
            localVarQueryParameters['EnforceStrictOfferPhaseLongTextOutput'] = ObjectSerializer.serialize(enforceStrictOfferPhaseLongTextOutput, "boolean");
        }
        if (exportQuantityDetermination !== undefined) {
            localVarQueryParameters['ExportQuantityDetermination'] = ObjectSerializer.serialize(exportQuantityDetermination, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        if (forceIncludeDescriptions !== undefined) {
            localVarQueryParameters['ForceIncludeDescriptions'] = ObjectSerializer.serialize(forceIncludeDescriptions, "boolean");
        }
        if (treatNullItemNumberSchemaAsInvalid !== undefined) {
            localVarQueryParameters['TreatNullItemNumberSchemaAsInvalid'] = ObjectSerializer.serialize(treatNullItemNumberSchemaAsInvalid, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts SIA 451 files to Oenorm files
     * @param siaFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToOenorm(siaFile, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options = {}) {
        const localVarPath = this.basePath + '/conversion/sia/oenorm';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (destinationOenormType !== undefined) {
            localVarQueryParameters['DestinationOenormType'] = ObjectSerializer.serialize(destinationOenormType, "'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'");
        }
        if (tryRepairProjectStructure !== undefined) {
            localVarQueryParameters['TryRepairProjectStructure'] = ObjectSerializer.serialize(tryRepairProjectStructure, "boolean");
        }
        if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
            localVarQueryParameters['SkipTryEnforceSchemaCompliantXmlOutput'] = ObjectSerializer.serialize(skipTryEnforceSchemaCompliantXmlOutput, "boolean");
        }
        if (removeUnprintableCharactersFromTexts !== undefined) {
            localVarQueryParameters['RemoveUnprintableCharactersFromTexts'] = ObjectSerializer.serialize(removeUnprintableCharactersFromTexts, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (siaFile !== undefined) {
            localVarFormParams['siaFile'] = siaFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SiaConversionApi = SiaConversionApi;
var StatusApiApiKeys;
(function (StatusApiApiKeys) {
})(StatusApiApiKeys = exports.StatusApiApiKeys || (exports.StatusApiApiKeys = {}));
class StatusApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[StatusApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary Reports the health status of the AVACloud API
     * @param {*} [options] Override http request options.
     */
    statusGetStatus(options = {}) {
        const localVarPath = this.basePath + '/status';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.StatusApi = StatusApi;
var ValidationApiApiKeys;
(function (ValidationApiApiKeys) {
})(ValidationApiApiKeys = exports.ValidationApiApiKeys || (exports.ValidationApiApiKeys = {}));
class ValidationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Dangl.Identity': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ValidationApiApiKeys[key]].apiKey = value;
    }
    set accessToken(token) {
        this.authentications['Dangl.Identity'].accessToken = token;
    }
    /**
     *
     * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
     * @param avaFile The file to validate
     * @param fileValidationSourceType You need to indicate which type of file is being provided, there is no auto detection mechanism
     * @param {*} [options] Override http request options.
     */
    validationValidateFile(avaFile, fileValidationSourceType, options = {}) {
        const localVarPath = this.basePath + '/validation/file';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (fileValidationSourceType !== undefined) {
            localVarQueryParameters['fileValidationSourceType'] = ObjectSerializer.serialize(fileValidationSourceType, "'Gaeb' | 'Oenorm'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        if (avaFile !== undefined) {
            localVarFormParams['avaFile'] = avaFile;
        }
        localVarUseFormData = true;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ValidationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
     * @param avaProjectValidationSourceOptions The options used for the validation operation
     * @param {*} [options] Override http request options.
     */
    validationValidateProject(avaProjectValidationSourceOptions, options = {}) {
        const localVarPath = this.basePath + '/validation/project';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'avaProjectValidationSourceOptions' is not null or undefined
        if (avaProjectValidationSourceOptions === null || avaProjectValidationSourceOptions === undefined) {
            throw new Error('Required parameter avaProjectValidationSourceOptions was null or undefined when calling validationValidateProject.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(avaProjectValidationSourceOptions, "PostAvaProjectValidationSourceOptions")
        };
        this.authentications['Dangl.Identity'].applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ValidationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ValidationApi = ValidationApi;
//# sourceMappingURL=api.js.map