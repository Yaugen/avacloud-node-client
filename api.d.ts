/**
 * AVACloud API 1.31.3-beta0009
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.31.3-beta0009
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/// <reference types="node" />
import localVarRequest = require('request');
import http = require('http');
/**
* This enumeration represents the status of an addendum, 'Nachtrag' in German
*/
export declare class AddendumStatusDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Indicates the origin of an element.
*/
export declare class AdditionTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Data transfer class to convey api errors
*/
export declare class ApiError {
    /**
    * This dictionary contains a set of all errors and their messages
    */
    'errors'?: {
        [key: string]: Array<string>;
    };
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents a single article, usually used within ProductData
*/
export declare class ArticleDataDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The name (or brand name) for this article, usually given by the supplier or vendor.
    */
    'name'?: string;
    /**
    * An article number that describes it, useful when integrating other systems.
    */
    'articleNumber'?: string;
    /**
    * Quantity for this article. If this is used within a Position, the quantity here should be the quantity required for the full quantity of the position, not for a single unit.
    */
    'quantity': number;
    /**
    * The unit tag for this single ArticleData.
    */
    'unitTag'?: string;
    /**
    * This is an optional text element that can be used to further describe the ArticleData.
    */
    'description'?: string;
    /**
    * Short description for this ITextElement element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard
*/
export declare class AwardTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This is a class that represents the information about a bank connection. It is usually used within a PartyInformation.
*/
export declare class BankingInformationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The name of the bank.
    */
    'name'?: string;
    /**
    * The international identifier for the bank account.
    */
    'iban'?: string;
    /**
    * The account number. Typically no longer used since the introduction of IBAN within the SEPA area.
    */
    'accountNumber'?: string;
    /**
    * The international bank identifier.
    */
    'bic'?: string;
    /**
    * The routing number for the bank. Typically no longer used since the introduction of IBAN within the SEPA area.
    */
    'routingNumber'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class holds means to calculate mathematical expressions from given strings.
*/
export declare class CalculationDto {
    /**
    * Descriptive text for this calculation.
    */
    'description'?: string;
    /**
    * This Calculation's mathematical expression. Please note that thousands separators are not supported. Both comma and point will be treated as decimal separators.
    */
    'formula'?: string;
    /**
    * The calculated result from the formula, 0 if invalid.
    */
    'result': number;
    /**
    * Whether the Formula is a valid expression.
    */
    'valid': boolean;
    /**
    * Will be -1 if the Formula is correct, else it will show the position in the formula where an error was encountered. This is a zero based index.
    */
    'errorPositionInLine': number;
    /**
    * These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * Referenced catalogues for this Calculation.
    */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class describes an external catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
*/
export declare class CatalogueDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This is used to store the GAEB XML Id within this Catalogue. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    /**
    * The name that is given for this catalogue.
    */
    'name'?: string;
    /**
    * Additional information about this catalogue.
    */
    'description'?: string;
    /**
    * If given, this gives a classification for the contents of the catalogue
    */
    'catalogueType': CatalogueTypeDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class is used to link data between catalogues and objects.
*/
export declare class CatalogueReferenceDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This points to the item in the catalogue itself. This means that, for example when this quantity assignment references a \"DIN 276\" catalogue, this property indicates the number / identifier / key in DIN 276 that is referenced.
    */
    'catalogueReferenceKey'?: string;
    /**
    * The Id of the CatalogueReference that is targeted by this item. Set this property to set the referenced catalogue.
    */
    'catalogueReferenceId': string;
    /**
    * These are CatalogueReference that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * This returns the referenced catalogue. Will return null if there is no reference or the catalogue is not present in the ProjectCatalogues.
    */
    'catalogue'?: CatalogueDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration describes the type of a catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
*/
export declare class CatalogueTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Indicates if this service specification item is commissioned (and therefore should be executed), postponed for later or undefined.
*/
export declare class ComissionStatusDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class holds specialized information that is relevant to trade or commerce based data exchange scenarios, e.g. between customers, vendors, suppliers and distributors. It is used when exporting to GAEB XML 9x exchange phases.
*/
export declare class CommercePropertiesDto {
    /**
    * This maps to ArtNo in GAEB XML and represents an article number given by the supplier.
    */
    'articleNumber'?: string;
    /**
    * This maps to EAN in GAEB XML and represents an GTIN (formerly EAN) article number.
    */
    'eanGtinArticleNumber'?: string;
    /**
    * This maps to ArtNoID in GAEB XML and represents an ILN article number.
    */
    'ilnArticleNumber'?: string;
    /**
    * This maps to CatalogNo in GAEB XML and represents an identifier of a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences.
    */
    'catalogueNumber'?: string;
    /**
    * This maps to CatalogArtNo in GAEB XML and represents a key that maps to an entry in a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences.
    */
    'catalogueArticleNumber'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents the linking to a complementary position with a specific quantity set. For example, Position 'A' could be complementing Position 'B' with a total quantity of 20 units
*/
export declare class ComplementedByQuantityDto {
    /**
    * The quantity that is complemented. E.g., if the base position has a quantity of 100 m² of a brick wall, a complementing position might be for 'walls that exceed 3 m height' and for a total quantity of 10 m².
    */
    'quantity': number;
    /**
    * This is the reference to the Id of the Position that is complementing. This means it does NOT reference the base position but the one that contains the actual addition.
    */
    'complementingPositionId'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* The GAEB exchange phase to transform to
*/
export declare class DestinationGaebExchangePhase {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Represents valid GAEB target types
*/
export declare class DestinationGaebType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Represents valid Oenorm target types
*/
export declare class DestinationOenormType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Represents valid REB target types
*/
export declare class DestinationRebType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration represents the unit of a duration
*/
export declare class DurationUnitDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Indicates a ServiceSpecification's exchange phase, based on the GAEB exchange phases.
*/
export declare class ExchangePhaseDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Base interface definition for elements within an ElementContainerBase.
*/
export declare class IElementDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This is used to store the GAEB XML Id within this IElement. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    /**
    * This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German.
    */
    'addendumNumber'?: string;
    'projectCatalogues'?: Array<CatalogueDto>;
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    'elementTypeDiscriminator': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class ExecutionDescriptionDto extends IElementDto {
    /**
    * Blocks within an ExecutionDescription contain the actual information.
    */
    'blocks'?: Array<NoteTextDto>;
    /**
    * Labels this ExecutionDescription.
    */
    'label'?: string;
    /**
    * Uniquely identifies this ExecutionDescription.
    */
    'identifier'?: string;
    'elementType'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enum represents the source type for a file based validation operation
*/
export declare class FileValidationSourceType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class ForgotPasswordPost {
    'identifier': string;
    'preferredLanguages'?: Array<string>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Indicates the status of the AVACloud service
*/
export declare class GetStatus {
    /**
    * If any problems in the service health are known, this is set to false
    */
    'isHealthy': boolean;
    /**
    * The current version of the AVACloud service
    */
    'version'?: string;
    /**
    * The environment of the current instance
    */
    'environment'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This is used in an ElementContainerBase to hold the price composition.
*/
export declare class GrossPriceComponentDto {
    /**
    * This components tax rate.
    */
    'taxRate': number;
    /**
    * This is the factor of applied deductions for this component
    */
    'deductionFactor': number;
    /**
    * The total net price for all components of a given tax rate.
    */
    'totalNet': number;
    /**
    * The resulting price component after applied deductions
    */
    'totalDeducted': number;
    /**
    * The total tax amount for all components of a given tax rate.
    */
    'totalTax': number;
    /**
    * The total gross price for all components of a given tax rate.
    */
    'totalGross': number;
    /**
    * The total gross price for all components of a given tax rate, after applied deductions.
    */
    'totalGrossDeducted': number;
    /**
    * The total tax amount for all components of a given tax rate, after applied deductions.
    */
    'totalTaxDeducted': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class HttpStatusCode {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents as identifier of a certain service specification's element and is uniquely within the service specification.
*/
export declare class ItemNumberDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * Will return this ItemNumber as point delimited string. Will not distinguish between upper- and lowercase and return an all-lowercase representation. Will consider first numbers, then characters, e.g. 1a is considered preceding aa.
    */
    'stringRepresentation'?: string;
    /**
    * Indicates if the characters and the length of the Identifiers match the current ItemNumberSchema.
    */
    'isSchemaCompliant': boolean;
    /**
    * Used for representing and validating this ItemNumber.
    */
    'itemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * Collection of the single identifiers in this ItemNumber. P.e., \"02.03.004\" will have three elements \"02\", \"03\", and \"004\". Since ReadOnlyObservableCollection`1 does have the event set to protected, it can be accessed like this: (itemNumber.Identifiers as INotifyCollectionChanged).CollectionChanged
    */
    'identifiers'?: Array<string>;
    /**
    * This indicates if this item number is at the lot level. Find out more about lots in the documentation.
    */
    'isLot': boolean;
    /**
    * This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
    */
    'hierarchyLevel': number;
    /**
    * This property indicates if this ItemNumber is attached to an object of the Position type.
    */
    'isAttachedToPosition': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* The schema for ItemNumber's in a Project.
*/
export declare class ItemNumberSchemaDto {
    /**
    * The count of tiers in the ItemNumberSchema
    */
    'totalLength': number;
    /**
    * The collection of tiers for this ItemNumberSchema.
    */
    'tiers'?: Array<ItemNumberSchemaTierDto>;
    /**
    * The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
    */
    'separator'?: string;
    /**
    * This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
    */
    'filler'?: string;
    /**
    * This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store ÖNorm service specification structure types.
    */
    'identifier'?: string;
    /**
    * This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
    */
    'skipNonExistingLevelsInPositionItemNumbers': boolean;
    /**
    * This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
    */
    'skippedTiersFiller'?: string;
    /**
    * This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
    */
    'schemaIsCorrectlyDefined': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Represents information about a single Tier in an ItemNumber.
*/
export declare class ItemNumberSchemaTierDto {
    /**
    * The (maximum) length for this tier. Will not accept a length less than 1. Defaults to 1 if length less than one is specified.
    */
    'length': number;
    /**
    * This ItemNumberSchemaTier's type.
    */
    'type': ItemNumberTypeDto;
    /**
    * This specifies which ItemNumberSchemaTierType this tier represents. This can be, for example, a group tier / level, a position level or a lot level.
    */
    'tierType': ItemNumberSchemaTierTypeDto;
    /**
    * Indicates if this tier represents a lot. See the documentation for more information about lots.
    */
    'isLot': boolean;
    /**
    * This value is the increment, or step size, that should be used for new item numbers. It defaults to DEFAULT_INCREMENT, but can be changed to any other positive number greater than zero. Invalid values make this be set to one '1'
    */
    'increment': number;
    /**
    * This is an optional name for the given tier
    */
    'tierName'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Specifies the type an ItemNumberSchemaTier represents. For example, a tier may indicate to be used for positions or for groups.
*/
export declare class ItemNumberSchemaTierTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Determines the type of an ItemNumberSchema
*/
export declare class ItemNumberTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Based on the PriceComponent, this class is responsible for labour time components.
*/
export declare class LabourPriceComponentDto {
    /**
    * The label associated with this price component. Will be taken from the parent Projects ProjectInformation.
    */
    'label'?: string;
    /**
    * The total, calculated price of this component. Will multiply the calculated amount of hours with the ServiceSpecifications hourly wage rate.
    */
    'price': number;
    /**
    * The cost per hour of manual labor.
    */
    'hourlyWage': number;
    /**
    * The single Calculation elements this price component is composed of.
    */
    'values'?: Array<CalculationDto>;
    /**
    * Indicates if the ServiceSpecification's standard HourlyWage is to be used or a custom value.
    */
    'useOwnHourlyWage': boolean;
    /**
    * The total, calculated time of this component. Will return the result rounded to three decimal places.
    */
    'totalTime': number;
    /**
    * These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class LoginPost {
    'identifier': string;
    'password': string;
    'staySignedIn': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class NoteTextDto extends IElementDto {
    /**
    * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special opening text at the beginning of the project. For example, in GAEB XML, this would map to the GAEB.Award.AddText. Typically, such texts describe project-wide contractual definitions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
    */
    'isOpeningText': boolean;
    /**
    * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special closing text at the end of the project. For Example, in GAEB XML, this would map to the GAEB.AddText. Typically, such texts are used to describe project wide finishing descriptions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
    */
    'isClosingText': boolean;
    /**
    * Short description for this DescriptionBase element.
    */
    'shortText'?: string;
    /**
    * Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.
    */
    'additionType': AdditionTypeDto;
    /**
    * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    /**
    * This is an optional internal identifier that may be used to add additional information to this NoteText. It is not supported in GAEB import or export.
    */
    'identifier'?: string;
    /**
    * This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
    */
    'standardizedDescription'?: StandardizedDescriptionDto;
    'elementType'?: string;
    /**
    * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.
    */
    'descriptionId'?: string;
    /**
    * This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for NoteTexts.
    */
    'oenormNoteTextProperties'?: OenormNoteTextPropertiesDto;
    'hasBidderCommentInHtmlLongText': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Basic information about Object check validation details, commonly used when checking GAEB 2000 files
*/
export declare class ObjectValidationCheckDetails {
    /**
    * The path under which the element with error was found.
    */
    'elementPath'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for NoteTexts.
*/
export declare class OenormNoteTextPropertiesDto {
    /**
    * This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
    */
    'originCode': OenormOriginCodeDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
*/
export declare class OenormOriginCodeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.
*/
export declare class OenormPositionPropertiesDto {
    /**
    * This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
    */
    'originCode': OenormOriginCodeDto;
    /**
    * This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in ÖNorm.
    */
    'openingTextIsFreeText': boolean;
    /**
    * This indicates if the ÖNorm 'wesentliche position' mark is set
    */
    'isMainPosition': boolean;
    /**
    * This indicates if the ÖNorm position was a 'ungeteilteposition' (undivided position). This will only be taken into account when the position is also the sole element inside it's parent group
    */
    'isUndividedPosition': boolean;
    /**
    * In some ÖNorm formats, the short text can have it's own addition, so the text is split up in OenormShortText and OenormShortTextAddition If this is set, the short text property of the parent position will be ignored.
    */
    'oenormShortText'?: string;
    /**
    * In some ÖNorm formats, the short text can have it's own addition, so the text is split up in OenormShortText and OenormShortTextAddition If this is set, the short text property of the parent position will be ignored.
    */
    'oenormShortTextAddition'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class models special properties that only apply to some exchange scenarios where ÖNorm is used.
*/
export declare class OenormPropertiesDto {
    /**
    * This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in ÖNorm
    */
    'originCode': OenormOriginCodeDto;
    /**
    * This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in ÖNorm.
    */
    'openingTextIsFreeText': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Indicates where a service specification was originally created.
*/
export declare class OriginDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Represents information about a party (a site or an organization).
*/
export declare class PartyInformationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This party's name.
    */
    'name'?: string;
    /**
    * This party's street.
    */
    'street'?: string;
    /**
    * This party's ZipCode.
    */
    'zipCode'?: string;
    /**
    * This party's City.
    */
    'city'?: string;
    /**
    * This party's Country.
    */
    'country'?: string;
    /**
    * This party's Identifier.
    */
    'identifier'?: string;
    /**
    * Remarks for this party.
    */
    'remarks'?: string;
    /**
    * An email address for this party.
    */
    'email'?: string;
    /**
    * A phone number for this party.
    */
    'phone'?: string;
    /**
    * The name of a contact person.
    */
    'contactPersonName'?: string;
    /**
    * This is an identifier related to this PartyInformation and their internal reference of the tender (or award). This might be used to assign an identifier (German \"Vergabenummer\") for the current project. This is typically only used in Buyer and Bidder representations and should map to the concept of \"Vergabenummer\" or \"AwardNo\" in GAEB.
    */
    'awardIdentifier'?: string;
    /**
    * This property indicates if the party is registered within the European Economic Area.
    */
    'isInEuropeanEconomicArea': boolean;
    /**
    * If this is within the European Economic Area (see IsInEuropeanEconomicArea, then as a business entity it likely has an EU VAT Id.
    */
    'vatId'?: string;
    /**
    * The fax number for this party.
    */
    'fax'?: string;
    /**
    * The two letter ISO country code, e.g. DE for Germany.
    */
    'countryCode'?: string;
    /**
    * Depending on which party this class represents, it might have either a 'creditor' or 'debtor' number. This is often used in internal accounting systems.
    */
    'creditorOrDebtorIdentifier'?: string;
    /**
    * The Global Location Number (GLN) is issued by GS1 and is intended to be a unique identifier for the physical address of a party, e.g. a business office.
    */
    'globalLocationNumber'?: string;
    /**
    * This list contains information about bank accounts associated with this PartyInformation. It's typically used for buyers and bidders.
    */
    'bankingInformation'?: Array<BankingInformationDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class PositionDto extends IElementDto {
    /**
    * Will return the price per unit, rounded according to the project settings or the default value of three decimal places
    */
    'unitPrice': number;
    /**
    * You can use this property to directly set the unit price for this position. This will override any given PriceComponents
    */
    'unitPriceOverride'?: number;
    /**
    * Will return this Position's total quantity, rounded to three decimal places.
    */
    'quantity': number;
    /**
    * You can use this property to directly set the quantity for this position. This will override any given QuantityComponents
    */
    'quantityOverride'?: number;
    /**
    * The tag of the unit used for this positions quantity.
    */
    'unitTag'?: string;
    /**
    * The components for labour time in this Position.
    */
    'labourComponents'?: LabourPriceComponentDto;
    /**
    * The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation.
    */
    'priceComponents'?: Array<PriceComponentDto>;
    /**
    * The quantity components of this Position.
    */
    'quantityComponents'?: Array<CalculationDto>;
    /**
    * Further structuring of this Position.
    */
    'subDescriptions'?: Array<SubDescriptionDto>;
    /**
    * Indicates the status of this Position's comission.
    */
    'comissionStatus': ComissionStatusDto;
    /**
    * A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions.
    */
    'complementedBy'?: Array<string>;
    /**
    * Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property.
    */
    'complemented': boolean;
    /**
    * Indicates that the amount for this Position is to be set by the bidder.
    */
    'amountToBeEnteredByBidder': boolean;
    /**
    * Indicates if the bidder demands for prices to be broken up into their price components.
    */
    'priceCompositionRequired': boolean;
    /**
    * Indicates if this Position should use a different TaxRate than what is the default for the Project.
    */
    'useDifferentTaxRate': boolean;
    /**
    * Will return either the parent ServiceSpecification's TaxRate or it's own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions)
    */
    'taxRate': number;
    /**
    * The ItemNumber for this Position.
    */
    'itemNumber'?: ItemNumberDto;
    /**
    * The rate of deductions, i.e. 0.12m means 12% price deduction.
    */
    'deductionFactor': number;
    /**
    * Returns the product of UnitPrice times Quantity.
    */
    'totalPrice': number;
    /**
    * The total gross price for this Position.
    */
    'totalPriceGross': number;
    /**
    * Total gross price after applied deductions.
    */
    'totalPriceGrossDeducted': number;
    /**
    * Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position.
    */
    'deductedPrice': number;
    /**
    * This indicates the type of a position. If this is an alternative position, its AlternativeTo property should be set to the id of the position it can replace.
    */
    'positionType': PositionTypeDto;
    /**
    * Indicates the PriceType of this Position.
    */
    'priceType': PriceTypeDto;
    /**
    * This indicates if this position is regular or describing a labour / hourly paid work service
    */
    'serviceType': ServiceTypeDto;
    /**
    * This property describes additional information about a product being used within this Position. For example, a pipe position, per length unit, could be composed of different pipe segments, fitting and other accessory articles.
    */
    'productData'?: ProductDataDto;
    /**
    * Short description for this DescriptionBase element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    /**
    * Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.
    */
    'additionType': AdditionTypeDto;
    'elementType'?: string;
    /**
    * Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
    */
    'quantityAssignments'?: Array<QuantityAssignmentDto>;
    /**
    * The CommerceProperties support specialized information that is only useful in GAEB XML 9x data exchange phases. It is intended to provide article information.
    */
    'commerceProperties'?: CommercePropertiesDto;
    /**
    * If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position.
    */
    'alternativeTo'?: string;
    /**
    * This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
    */
    'alternativeIdentifier'?: number;
    /**
    * This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It's different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
    */
    'alternativeGroupIdentifier'?: number;
    /**
    * If this is true, it indicates that the position is intended to be a lump sum, \"Pauschal\" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used.
    */
    'isLumpSum': boolean;
    /**
    * This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches \"Bezugsposition\" in GAEB. This can be used for positions that repeat partially or are linked together
    */
    'repetitionTo'?: string;
    'type'?: string;
    /**
    * This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
    */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
    * This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it's up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here.
    */
    'complementedByQuantities'?: Array<ComplementedByQuantityDto>;
    /**
    * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details.
    */
    'executionDescriptionReference'?: string;
    /**
    * This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all.
    */
    'notOffered': boolean;
    /**
    * This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.
    */
    'oenormPositionProperties'?: OenormPositionPropertiesDto;
    /**
    * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.
    */
    'descriptionId'?: string;
    /**
    * This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
    */
    'hierarchyLevel': number;
    /**
    * This indicates, if this element is part of an addendum an, if yes, with what status.
    */
    'addendumStatus'?: AddendumStatusDto;
    'hasBidderCommentInHtmlLongText': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This is a classification for Position elements.
*/
export declare class PositionTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Options for validating an AVA project
*/
export declare class PostAvaProjectValidationSourceOptions {
    /**
    * The project that should be validated
    */
    'avaProject': ProjectDto;
    /**
    * The index of the ServiceSpecification that should be validated. If not given, will default to the first one in the project.
    */
    'serviceSpecificationIndex'?: number;
    /**
    * This can optionally be specified to simulate a conversion to a specific target.
    */
    'validationType': ValidationType;
    /**
    * This can optionally be supplied to test for a specific exchange phase. For example, missing prices will only trigger errors in some specific exchange phases. Please note: If a conversion to a specific format, e.g. GAEB or ÖNorm, is given, this parameter is not applied to the internal conversion. The converter options must be set in the appropriate properties as well.
    */
    'exchangePhase'?: ExchangePhaseDto;
    /**
    * Options for importing the AVA project
    */
    'avaSourceOptions'?: PostAvaSourceOptions;
    /**
    * Options for conversion to Oenorm. Should be given if ValidationType is set to Oenorm.
    */
    'oenormDestinationOptions'?: PostOenormDestinationOptions;
    /**
    * Options for conversion to GAEB. Should be given if ValidationType is set to GAEB.
    */
    'gaebDestinationOptions'?: PostGaebDestinationOptions;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Options for conversions from AVA
*/
export declare class PostAvaSourceOptions {
    /**
    * If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
    */
    'tryAutoGenerateItemNumbersAndSchema': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Options for conversions to GAEB
*/
export declare class PostGaebDestinationOptions {
    /**
    * Defaults to GAEB XML V3.2
    */
    'destinationGaebType': DestinationGaebType;
    /**
    * Defaults to none, meaning no transformation will be done
    */
    'targetExchangePhaseTransform': DestinationGaebExchangePhase;
    /**
    * Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
    */
    'enforceStrictOfferPhaseLongTextOutput': boolean;
    /**
    * Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the 'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for 'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the 'QuantityComponents' property.
    */
    'exportQuantityDetermination': boolean;
    /**
    * If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
    */
    'removeUnprintableCharactersFromTexts': boolean;
    /**
    * If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
    */
    'forceIncludeDescriptions': boolean;
    /**
    * When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
    */
    'treatNullItemNumberSchemaAsInvalid': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Options for conversions to Oenorm
*/
export declare class PostOenormDestinationOptions {
    /**
    * Defaults to Lv2015
    */
    'destinationOenormType': DestinationOenormType;
    /**
    * Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
    */
    'tryRepairProjectStructure': boolean;
    /**
    * If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
    */
    'skipTryEnforceSchemaCompliantXmlOutput': boolean;
    /**
    * If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
    */
    'removeUnprintableCharactersFromTexts': boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class provides means to store information about a price and it's composition. Note that this is referencing to a single price component, so for example a Position would have a list of PriceComponents, one for Material, one for Labour etc.
*/
export declare class PriceComponentDto {
    /**
    * The total, calculated price of this component.
    */
    'price': number;
    /**
    * The label associated with this price component. Will be taken from the parent Projects ProjectInformation.
    */
    'label'?: string;
    /**
    * The single Calculation elements this price component is composed of.
    */
    'values'?: Array<CalculationDto>;
    /**
    * These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration models types of price components for better classification.
*/
export declare class PriceComponentTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Holds global price information for a ServiceSpecification
*/
export declare class PriceInformationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The amount of currency per one hour of manual labour work in this project.
    */
    'hourlyWage': number;
    /**
    * The final, total price will be deducted by this rate.
    */
    'deductionFactor': number;
    /**
    * This is given when there is only one flat price for the whole service specification.
    */
    'flatSum': number;
    /**
    * Global tax rate for the project. Note that certain elements may have a different, specific tax rate.
    */
    'taxRate': number;
    /**
    * Trade discounts for offered in this ServiceSpecification.
    */
    'tradeDiscounts'?: Array<TradeDiscountDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enum configures rounding modes for price calculations in projects
*/
export declare class PriceRoundingModeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This indicates the price type of a IPricedElement.
*/
export declare class PriceTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents data about products and their vendor
*/
export declare class ProductDataDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This PartyInformation is used to describe details about the vendor of this ProductData.
    */
    'vendor'?: PartyInformationDto;
    /**
    * The collection of ArticleData that describe this product, e.g. a pipe product could be composed out of multiple pipe segments and fittings.
    */
    'articles'?: Array<ArticleDataDto>;
    /**
    * Short description for this ITextElement element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* A Project contains all relevant information for a construction project.
*/
export declare class ProjectDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * This property controls the accuracy of all price properties, meaning how many decimal places are preserved in calculations. It defaults to DEFAULT_PRICE_ACCURACY. Please see the Dangl.AVA documentation for further information about decimal precision.
    */
    'priceAccuracy': number;
    /**
    * This forces total prices to be the strict product of quantities times unit price in positions. It is enabled by default. If this is disabled, both the unit price and the total price of positions is calculated from the non-rounded values. Please see the documentation for a more detailed explanation of this setting.
    */
    'forceStrictTotals': boolean;
    /**
    * This property controls the rounding mode of all price properties, meaning how rounding of decimal places is performed in price calculations. It defaults to DEFAULT_ROUNDING_MODE. Please see the Dangl.AVA documentation for further information about decimal precision.
    */
    'priceRoundingMode': PriceRoundingModeDto;
    /**
    * The ProjectInformation contains information that describes the project and its structure.
    */
    'projectInformation'?: ProjectInformationDto;
    /**
    * The ServiceSpecifications in this Project.
    */
    'serviceSpecifications'?: Array<ServiceSpecificationDto>;
    /**
    * This is used to store the GAEB XML Id within this Project. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* General information about a Project.
*/
export declare class ProjectInformationDto {
    /**
    * Information about the buyer.
    */
    'buyer'?: PartyInformationDto;
    /**
    * Description for the project.
    */
    'description'?: string;
    /**
    * Short description for the project.
    */
    'descriptionShort'?: string;
    /**
    * Name of the project.
    */
    'name'?: string;
    /**
    * Information about the site.
    */
    'site'?: PartyInformationDto;
    /**
    * The ItemNumberSchema used in the project.
    */
    'itemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * Short label for the currency used.
    */
    'currencyShort'?: string;
    /**
    * Full label of the currency used.
    */
    'currencyLong'?: string;
    /**
    * Label for the labour time part of prices used in the project.
    */
    'labourTimeLabel'?: string;
    /**
    * Labels for the price components used in the project. Caution: Removal of a price component will trigger to have dependent price informations be deleted in IElements that use this property. If this property is changed or altered after the project has already been used, it is strongly advised to do operations step by step, e.g. if renaming and reordering multiple price components, this should be done one by one. Otherwise, a combination of rename and reordering will not be correctly propagated downwards to child objects in this Project.
    */
    'priceComponents'?: Array<string>;
    /**
    * This dictionary specifies actual types used for the PriceComponents. For example, a single price component might have the name 'Material' as a string, ans this dictionary would then have a key 'Material' and a value of Materials. You can not add keys here that are not also present in the PriceComponents property, and removing price components will also remove them from this dictionary here.
    */
    'priceComponentTypes'?: {
        [key: string]: PriceComponentTypeDto;
    };
    /**
    * This bool indicates if this project allows the bidder to add bidder comments. Bidder comments are a way to attach clarifying information when submitting an offer.
    */
    'bidderCommentAllowed': boolean;
    /**
    * This property indicates if the project should allow side offers from contractors. In GAEB, a side offer would typically be in exchange phase 85.
    */
    'sideOffersAllowed': boolean;
    /**
    * This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard
    */
    'awardType': AwardTypeDto;
    /**
    * This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary
    */
    'specialAwardKind': SpecialAwardKindDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Check details specificly for checking ProjectDto objects
*/
export declare class ProjectValidationCheckDetails {
    /**
    * The id of the element
    */
    'elementId': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of their parent Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
*/
export declare class QuantityAssignmentDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The total quantity in this quantity assignment
    */
    'quantity': number;
    /**
    * These are Catalogue that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * Referenced catalogues for this QuantityAssignment.
    */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class RegisterPost {
    'username': string;
    'email': string;
    'password': string;
    'preferredLanguages'?: Array<string>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ResponseErrorType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents a single key reference within the German STLB \"Standardleistungsbuch Bau\"
*/
export declare class STLBKeyDto {
    /**
    * This identifier is required and uniquely describes a single reference within the STLB standard. It maps to \"ArtChrIdent\" in GAEB XML
    */
    'artIdentifier': number;
    /**
    * This optional index property further categorizes a single reference within the STLB standard. It maps to \"ArtChIdx\" in GAEB XML
    */
    'artIndex'?: number;
    /**
    * This optional identifier further specifies the execution kind of the reference in the STLB standard. It maps to \"ChVIdent\" in GAEB XML
    */
    'kindIdentifier'?: number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents a specialized reference to the German STLB \"Standardleistungsbuch Bau\". The STLB is a commercial offering and describes common services in the construction sector. When this is used, this describes the exact type of a service via a reference to this standard
*/
export declare class STLBReferenceDto {
    /**
    * The date of the STLB version. Typically, only the Year and Month are used
    */
    'versionDate'?: Date;
    /**
    * The name of the catalogue within the STLB
    */
    'catalogueName'?: string;
    /**
    * The name of the group in STLB
    */
    'group'?: string;
    /**
    * The cost group this service is associated with
    */
    'costGroup'?: string;
    /**
    * The service area (or type) in the STLB
    */
    'serviceArea'?: string;
    /**
    * These keys may optionally be used to further reference multiple, specific items within the STLB
    */
    'keys'?: Array<STLBKeyDto>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This is the base class that holds information about a whole service specification.
*/
export declare class ServiceSpecificationDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectHourlyWage': number;
    /**
    * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectTaxRate': number;
    /**
    * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
    */
    'projectPriceComponents'?: Array<string>;
    /**
    * The ItemNumberSchema that is used within this project.
    */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * The IElements within this ElementContainerBase.
    */
    'elements'?: Array<IElementDto>;
    /**
    * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
    */
    'projectLabourTimeLabel'?: string;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateItemNumbers': boolean;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateElementIds': boolean;
    /**
    * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateItemNumbers': boolean;
    /**
    * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateElementIds': boolean;
    /**
    * Price composition by tax rate.
    */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
    * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
    */
    'ignoreChildPriceUpdates': boolean;
    /**
    * Net price after applied deductions.
    */
    'deductedPrice': number;
    /**
    * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
    */
    'deductionFactor': number;
    /**
    * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
    */
    'absoluteDeduction'?: number;
    /**
    * Will return this ElementContainerBase's total price.
    */
    'totalPrice': number;
    /**
    * The total gross price for this ElementContainerBase including all child elements.
    */
    'totalPriceGross': number;
    /**
    * Total gross price after applied deductions.
    */
    'totalPriceGrossDeducted': number;
    /**
    * Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not.
    */
    'priceType': PriceTypeDto;
    /**
    * Information about the bidder.
    */
    'bidder'?: PartyInformationDto;
    /**
    * This discriminator is used to identify different bidders in a project. It is different from the Identifier property in the Bidder in that the BidderDiscriminator is intended to be a numerical identifier within a project, while the Identifier does uniquely identify a bidder in the system independent of a specific project. This property should map to \"Bieternummer\" or \"BidderNo\" in GAEB.
    */
    'bidderDiscriminator'?: string;
    /**
    * This is used to store the GAEB XML Id within this ServiceSpecification. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
    */
    'gaebXmlId'?: string;
    /**
    * The ProjectInformation used within the Project in which this ElementContainerBase is contained. This is reference equal to the ProjectInformation used in the parent project.
    */
    'projectInformation'?: ProjectInformationDto;
    /**
    * This service specifications exchange phase, i.e. the current status in the project it is intended to be used (such as request for offer, offer, awarding...).
    */
    'exchangePhase': ExchangePhaseDto;
    /**
    * This indicates where the service specification originates, i.e. from an exchange file format or self created. If applicable, additional information is present in the OriginDetail property.
    */
    'origin': OriginDto;
    /**
    * This property complements the Origin property. Some formats, e.g. GaebXml might have additional information attached, e.g. GAEB XML V3.2 oder GAEB XML V3.1. This string property is used to hold such data. The Dangl.AVA module does not have a list of possible values, since this is defined in the native format assemblies, e.g. Dangl.GAEB or Dangl.Oenorm.
    */
    'originDetail'?: string;
    /**
    * Creation date of this ServiceSpecification.
    */
    'creationDate'?: Date;
    /**
    * Date indicating until when an offer has to be submitted. In German, this is often called the \"Eröffnungstermin\"
    */
    'offerByDate'?: Date;
    /**
    * Date indicating by when the buyer will select a contractor.
    */
    'decisionDate'?: Date;
    /**
    * String indicating where the physical submission of the offer is taking place.
    */
    'submissionLocation'?: string;
    /**
    * Description of this ServiceSpecification.
    */
    'description'?: string;
    /**
    * The name of this ServiceSpecification.
    */
    'name'?: string;
    /**
    * This PriceInformation contains global data for the ServiceSpecification. When inside a Project, do not set this property manually.
    */
    'priceInformation'?: PriceInformationDto;
    /**
    * These are Catalogue that are used within this ElementContainerBase. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * Referenced catalogues for this ElementContainerBase.
    */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    /**
    * The date when the execution of the services is scheduled to start
    */
    'plannedExecutionStart'?: Date;
    /**
    * The date then the execution of the services is scheduled to be finished
    */
    'plannedExecutionEnd'?: Date;
    /**
    * The date on which the contract has been awarded. This matches \"Auftragsdatum\" in GAEB
    */
    'contractDate'?: Date;
    /**
    * This value can be used to indicate the number or identifier of the contract. It matches \"Auftragsnummer\" in GAEB
    */
    'contractIdentifier'?: string;
    /**
    * This indicates how long the warranty period is for this ServiceSpecification
    */
    'warrantyDuration'?: WarrantyDurationDto;
    /**
    * The date on which the warranty period ends
    */
    'warrantyEnd'?: Date;
    /**
    * The date on which the services rendered by the bidder are scheduled to be approved by the buyer
    */
    'approvalDate'?: Date;
    /**
    * This should specify how the approval is performed by the buyer. This matches \"AcceptType\" in GAEB
    */
    'typeOfApproval'?: string;
    /**
    * This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German.
    */
    'addendumNumber'?: string;
    /**
    * This indicates, if this element is part of an addendum an, if yes, with what status.
    */
    'addendumStatus'?: AddendumStatusDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class ServiceSpecificationGroupDto extends IElementDto {
    /**
    * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectHourlyWage': number;
    /**
    * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
    */
    'projectTaxRate': number;
    /**
    * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
    */
    'projectPriceComponents'?: Array<string>;
    /**
    * The ItemNumberSchema that is used within this project.
    */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
    * The IElements within this ElementContainerBase.
    */
    'elements'?: Array<IElementDto>;
    /**
    * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
    */
    'projectLabourTimeLabel'?: string;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateItemNumbers': boolean;
    /**
    * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
    */
    'containsDuplicateElementIds': boolean;
    /**
    * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateItemNumbers': boolean;
    /**
    * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
    */
    'ignoreDuplicateElementIds': boolean;
    /**
    * Price composition by tax rate.
    */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
    * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
    */
    'ignoreChildPriceUpdates': boolean;
    /**
    * Net price after applied deductions.
    */
    'deductedPrice': number;
    /**
    * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
    */
    'deductionFactor': number;
    /**
    * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
    */
    'absoluteDeduction'?: number;
    /**
    * Will return this ElementContainerBase's total price.
    */
    'totalPrice': number;
    /**
    * The total gross price for this ElementContainerBase including all child elements.
    */
    'totalPriceGross': number;
    /**
    * Total gross price after applied deductions.
    */
    'totalPriceGrossDeducted': number;
    /**
    * Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not.
    */
    'priceType': PriceTypeDto;
    /**
    * Description for this ServiceSpecificationGroup.
    */
    'shortText'?: string;
    /**
    * Indicates if this service specification group is commissioned (and therefore should be executed), postponed for later or undefined.
    */
    'comissionStatus': ComissionStatusDto;
    /**
    * The ItemNumber for this INumberedElement interface.
    */
    'itemNumber'?: ItemNumberDto;
    'elementType'?: string;
    /**
    * This indicates if this group is the parent of a lot. See the documentation for more information about working with lots.
    */
    'isLot': boolean;
    /**
    * If this group is an alternative for a base group, then this property should point to the id of the group in this service specification that it can replace. If this is an alternative group to a base group, the PriceType should typically be set to \"WithoutTotal\" so this group does not factor into total costs. The PriceType is not changed when this property is set
    */
    'alternativeTo'?: string;
    'type'?: string;
    /**
    * This class models special properties that only apply to some exchange scenarios where ÖNorm is used.
    */
    'oenormProperties'?: OenormPropertiesDto;
    /**
    * This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
    */
    'hierarchyLevel': number;
    /**
    * This indicates, if this element is part of an addendum an, if yes, with what status.
    */
    'addendumStatus'?: AddendumStatusDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* The service type describes the type of service a Position represents.
*/
export declare class ServiceTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary
*/
export declare class SpecialAwardKindDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration identifies a pre-known standard used for referencing standardized descriptions.
*/
export declare class StandardReferenceTypeDto {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
*/
export declare class StandardizedDescriptionDto {
    /**
    * This enumeration identifies a pre-known standard used for referencing standardized descriptions.
    */
    'standardReferenceType': StandardReferenceTypeDto;
    /**
    * This string property is the identifier to map to the references standard. Its type is given in the StandardReferenceType
    */
    'standardReference'?: string;
    /**
    * This is a special reference to the German STLB \"Standardleistungsbuch Bau\" reference. If this is used, the StandardReference property should not be set.
    */
    'stlbReference'?: STLBReferenceDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This is appended to a Position and is used to separate the complete Position into smaller amounts to be described separately, for example concrete walls could be attached to different building storeys.
*/
export declare class SubDescriptionDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * Returns the total calculated sum of all quantity assignments. Will return the result rounded to three decimal places.
    */
    'quantity': number;
    /**
    * You can use this property to directly set the quantity for this sub description. This will override any given QuantityComponents
    */
    'quantityOverride'?: number;
    /**
    * Holds quantity information for this sub description. Quantity is listening to changes here and is reporting the total sum of all quantity components.
    */
    'quantityComponents'?: Array<CalculationDto>;
    /**
    * Indicates if the bidder is asked to specify an amount.
    */
    'amountToBeEnteredByBidder': boolean;
    /**
    * Identifier for this SubDescription.
    */
    'identifier'?: string;
    /**
    * Short description for this DescriptionBase element.
    */
    'shortText'?: string;
    /**
    * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
    */
    'longText'?: string;
    /**
    * If this is given, then the sub description has a different unit tag than the parent position.
    */
    'unitTag'?: string;
    /**
    * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
    */
    'htmlLongText'?: string;
    /**
    * Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.
    */
    'additionType': AdditionTypeDto;
    /**
    * This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
    */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
    * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions (or sub descriptions) should be executed in practice. Often, the position (or sub description) itself still has text of its own to highlight deviations from that or add more details. When working with import and export features, this property is only supported in GAEB 90 data exchange.
    */
    'executionDescriptionReference'?: string;
    /**
    * These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
    */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
    * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.
    */
    'descriptionId'?: string;
    'hasBidderCommentInHtmlLongText': boolean;
    'elementType'?: string;
    'elementTypeDiscriminator'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class TokenLoginPost {
    'identifier': string;
    'password': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class TokenRefreshPost {
    'refreshToken': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class TokenResponseGet {
    'accessToken'?: string;
    'error'?: string;
    'errorDescription'?: string;
    'expiresIn': number;
    'httpErrorReason'?: string;
    'httpStatusCode': HttpStatusCode;
    'identityToken'?: string;
    'isError': boolean;
    'refreshToken'?: string;
    'tokenType'?: string;
    'errorType': ResponseErrorType;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class holds information about offered trade discounts (Skonto in German)
*/
export declare class TradeDiscountDto {
    /**
    * Elements GUID identifier.
    */
    'id': string;
    /**
    * The amount of days for how long a declared trade discount applies. Must be a positive number, negative values will be ignored and not set.
    */
    'deadline': number;
    /**
    * The rate of the trade discount.
    */
    'rate': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class models the results of a single check performed during a validation action
*/
export declare class ValidationCheckResult {
    /**
    * The severity for this check. Usually, low severity checks do not impact data exchange with third party applications
    */
    'severity': ValidationSeverity;
    /**
    * The actual check that is represented by this result. Additional information may be found in other properties of this class, depending on the check.
    */
    'checkType': ValidationCheckType;
    /**
    * A human readable message describing the result of the check.
    */
    'message'?: string;
    /**
    * For CheckType of types ObjectValidation
    */
    'objectValidationCheckDetails'?: ObjectValidationCheckDetails;
    /**
    * For CheckType of types XmlSchemaCheck
    */
    'xmlSchemaValidationCheckDetails'?: XmlSchemaValidationCheckDetails;
    /**
    * For CheckType of types ProjectValidation
    */
    'projectValidationCheckDetails'?: ProjectValidationCheckDetails;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Enumeration for the different types of checks performed
*/
export declare class ValidationCheckType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class represents the result of a validation operation
*/
export declare class ValidationResult {
    /**
    * Indicates if the validation produced no errors
    */
    'isSchemaCompliant': boolean;
    /**
    * List of validation check results, which are usually errors
    */
    'checkResults'?: Array<ValidationCheckResult>;
    /**
    * The type of the validation that was performed
    */
    'validationType': ValidationType;
    /**
    * Name of the validated file
    */
    'fileName'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Indicates the severity of a check
*/
export declare class ValidationSeverity {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This enumeration represents the possible conversion targets when performing a validation
*/
export declare class ValidationType {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* This class does not represent a typical `TimeSpan` but has a scalar value int Duration and a DurationUnit Unit to represent durations as typically used in contracts, e.g. 5 Months
*/
export declare class WarrantyDurationDto {
    /**
    * The scalar value of the duration. This value must be equal to or bigger than zero (>= 0). Negative values can not be set and will be ignored.
    */
    'duration': number;
    /**
    * The unit of the duration
    */
    'unit': DurationUnitDto;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
* Check details for an XML schema validation result
*/
export declare class XmlSchemaValidationCheckDetails {
    /**
    * The line number on which the validation happened
    */
    'lineNumber': number;
    /**
    * The position in the line
    */
    'linePosition': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}
export declare class HttpBasicAuth implements Authentication {
    username: string;
    password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void;
}
export declare class ApiKeyAuth implements Authentication {
    private location;
    private paramName;
    apiKey: string;
    constructor(location: string, paramName: string);
    applyToRequest(requestOptions: localVarRequest.Options): void;
}
export declare class OAuth implements Authentication {
    accessToken: string;
    applyToRequest(requestOptions: localVarRequest.Options): void;
}
export declare class VoidAuth implements Authentication {
    username: string;
    password: string;
    applyToRequest(_: localVarRequest.Options): void;
}
export declare enum AslvConversionApiApiKeys {
}
export declare class AslvConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: AslvConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts Aslv files to Dangl.AVA projects
     * @param aslvFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToAva(aslvFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts Aslv files to Excel
     * @param aslvFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToExcel(aslvFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Aslv files to GAEB files
     * @param aslvFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToGaeb(aslvFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Aslv files to Oenorm files
     * @param aslvFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    aslvConversionConvertToOenorm(aslvFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum AvaConversionApiApiKeys {
}
export declare class AvaConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: AvaConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToAva(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts Dangl.AVA projects to Excel
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToExcel(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Dangl.AVA projects to GAEB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToGaeb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Dangl.AVA projects to Oenorm
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToOenorm(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Dangl.AVA projects to REB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param destinationRebType Defaults to D11
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToReb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationRebType?: 'D11' | 'X31GaebXmlV32', options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Dangl.AVA projects to SIA 451
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {*} [options] Override http request options.
     */
    avaConversionConvertToSia(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum DanglIdentityApiApiKeys {
}
export declare class DanglIdentityApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DanglIdentityApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @param model
     * @param {*} [options] Override http request options.
     */
    danglIdentityLoginAndReturnToken(model: TokenLoginPost, options?: any): Promise<{
        response: http.IncomingMessage;
        body: TokenResponseGet;
    }>;
    /**
     *
     * @param model
     * @param redirectUrl
     * @param {*} [options] Override http request options.
     */
    danglIdentityLoginWithCookie(model: LoginPost, redirectUrl?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @param model
     * @param {*} [options] Override http request options.
     */
    danglIdentityRefreshToken(model: TokenRefreshPost, options?: any): Promise<{
        response: http.IncomingMessage;
        body: TokenResponseGet;
    }>;
    /**
     *
     * @param registerModel
     * @param {*} [options] Override http request options.
     */
    danglIdentityRegister(registerModel: RegisterPost, options?: any): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @param forgotPasswordModel
     * @param {*} [options] Override http request options.
     */
    danglIdentityRequestPasswordReset(forgotPasswordModel: ForgotPasswordPost, options?: any): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @param {*} [options] Override http request options.
     */
    danglIdentitySignOutWithSignInManager(options?: any): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
}
export declare enum ExcelConversionApiApiKeys {
}
export declare class ExcelConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ExcelConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts Excel files to Dangl.AVA projects.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToAva(excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToExcel(excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Excel files to GAEB files.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToGaeb(excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts Excel files to Oenorm files.
     * @param excelFile The input file
     * @param readNewElements Defaults to false
     * @param rebuildItemNumberSchema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    excelConversionConvertToOenorm(excelFile: FileParameter, readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum GaebConversionApiApiKeys {
}
export declare class GaebConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: GaebConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts GAEB files to Dangl.AVA projects
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToAva(gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts GAEB files to Excel
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToExcel(gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToGaeb(gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts GAEB files to Oenorm files
     * @param gaebFile The input file
     * @param supportSkippedItemNumberLevelsInPositions Defaults to &#39;false&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just &#39;01.02&#39;, then it will be displayed as &#39;01.__.02&#39; if this is set to true.
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    gaebConversionConvertToOenorm(gaebFile: FileParameter, supportSkippedItemNumberLevelsInPositions?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum OenormConversionApiApiKeys {
}
export declare class OenormConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: OenormConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts ÖNorm files to Dangl.AVA projects
     * @param oenormFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToAva(oenormFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts ÖNorm files to Excel
     * @param oenormFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToExcel(oenormFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts ÖNorm files to GAEB files.
     * @param oenormFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToGaeb(oenormFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts ÖNorm files to Oenorm files.
     * @param oenormFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    oenormConversionConvertToOenorm(oenormFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum RebConversionApiApiKeys {
}
export declare class RebConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: RebConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts REB files to Dangl.AVA projects
     * @param rebFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToAva(rebFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts REB files to Excel
     * @param rebFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToExcel(rebFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts REB files to GAEB files
     * @param rebFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToGaeb(rebFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts REB files to Oenorm
     * @param rebFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    rebConversionConvertToOenorm(rebFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum SiaConversionApiApiKeys {
}
export declare class SiaConversionApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: SiaConversionApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Converts SIA 451 files to Dangl.AVA projects
     * @param siaFile The input file
     * @param removePlainTextLongTexts If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToAva(siaFile: FileParameter, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ProjectDto;
    }>;
    /**
     *
     * @summary Converts SIA 451 files to Excel
     * @param siaFile The input file
     * @param writePrices Defaults to true
     * @param writeLongTexts Defaults to true
     * @param conversionCulture The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToExcel(siaFile: FileParameter, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts SIA 451 files to GAEB files
     * @param siaFile The input file
     * @param destinationGaebType Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the &#39;QtyDeterm&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the &#39;QuantityComponents&#39; property of positions. Please see the entry for &#39;Quantity Determination&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the &#39;QuantityComponents&#39; property.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToGaeb(siaFile: FileParameter, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
    /**
     *
     * @summary Converts SIA 451 files to Oenorm files
     * @param siaFile The input file
     * @param destinationOenormType Defaults to Lv2015
     * @param tryRepairProjectStructure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param {*} [options] Override http request options.
     */
    siaConversionConvertToOenorm(siaFile: FileParameter, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): Promise<{
        response: http.IncomingMessage;
        body: Buffer;
    }>;
}
export declare enum StatusApiApiKeys {
}
export declare class StatusApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: StatusApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary Reports the health status of the AVACloud API
     * @param {*} [options] Override http request options.
     */
    statusGetStatus(options?: any): Promise<{
        response: http.IncomingMessage;
        body: GetStatus;
    }>;
}
export declare enum ValidationApiApiKeys {
}
export declare class ValidationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        'Dangl.Identity': OAuth;
    };
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ValidationApiApiKeys, value: string): void;
    set accessToken(token: string);
    /**
     *
     * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
     * @param avaFile The file to validate
     * @param fileValidationSourceType You need to indicate which type of file is being provided, there is no auto detection mechanism
     * @param {*} [options] Override http request options.
     */
    validationValidateFile(avaFile: FileParameter, fileValidationSourceType?: 'Gaeb' | 'Oenorm', options?: any): Promise<{
        response: http.IncomingMessage;
        body: ValidationResult;
    }>;
    /**
     *
     * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
     * @param avaProjectValidationSourceOptions The options used for the validation operation
     * @param {*} [options] Override http request options.
     */
    validationValidateProject(avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions, options?: any): Promise<{
        response: http.IncomingMessage;
        body: ValidationResult;
    }>;
}
export interface FileParameter {
    value: Buffer;
    options: {
        filename: string;
        contentType: string;
    };
}
